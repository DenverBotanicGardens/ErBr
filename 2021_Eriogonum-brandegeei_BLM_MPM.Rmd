---
title: "BLM_popbio_MPM"
author: "Michelle DePrenger-Levin"
date: "6/3/2021"
output: html_document
---

load packages
```{r}
rm(list=ls())

library(popbio)
library(ggplot2)
library(MuMIn)
library(lme4)
library(patchwork)

```

Gather demographic data 
```{r}
# BLM_erbr_popbio <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLM_demography_20210603.csv")

BLM_erbr_newplts <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLM_newplts.csv")

# removed rows before alive but kept first dead
BLM_erbr_lag <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLM_demolag_20210603.csv")


# by numbered transects 1:87 and years 1:5
# newPlts <- read.csv( "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLMnewplts_climate_20210601.csv")
         
# climate_erbr <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLM_climate_20210601.csv")

# seasonAllsites <- read.csv(file = "C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/2021_Eriogonum-brandegeei_climate.csv")
# seasonAllsites <- seasonAllsites[,-1]

## USFWS climate variables WaterDeficit over different months
CD <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2021_Eriogonum-brandegeei_SSA/2021_WaterDeficitData_Eriogonum-brandegeei_AlexKasdin-USFWS.csv")
head(CD)

# reshape(dats_BLM, idvar = names(dats_BLM)[c(1:8,12:15)], timevar = "Group.2", direction = "wide") # 

# climate_wide <- reshape(seasonAllsites, idvar = c("Group.3","Group.1"), timevar = "Group.2", direction = "wide")
# names(climate_wide) <- c("Year","Site","Tmean.summer","Ppt.summer","Tmean.winter","Ppt.winter","Tmean.fall","Ppt.fall")
# 
# table(climate_wide$Site)


# names(climate_wide)[3:8]
# climate_wide_scaled <- climate_wide
# climate_wide_scaled[names(climate_wide)[3:8]] <- lapply(climate_wide[names(climate_wide)[3:8]], scale) # dividing centered (subtracted means)
# head(climate_wide_scaled[climate_wide_scaled$Year > 2015,])

# some first year deads got through !!fixed, duplicate tags!! (from 2021_IntegratedPopulationModels_BLM-DBG-CNHP_formatdata)
# BLM_erbr_lag <- BLM_erbr_lag[!(BLM_erbr_lag$Year == 2016 & is.na(BLM_erbr_lag$Stage)),]

# BLM_erbr_lag$SiteName <- "BigBend_BLM"
# BLM_erbr_lag$SiteName[grep("CG", BLM_erbr_lag$Site)] <- "CastleGarden_BLM"
# BLM_erbr_lag$SiteName[grep("DGBLM", BLM_erbr_lag$Site)] <- "Droney_BLM"
# BLM_erbr_lag$SiteName[grep("GPQ", BLM_erbr_lag$Site)] <- "GardenParkQuarry_BLM"
# 
# BLM_erbr_lag_scaled <- merge(BLM_erbr_lag[,-1], climate_wide_scaled, 
#                              by.x = c("SiteName","Year"),
#                              by.y = c("Site","Year"))

BLM_erbr_lag_scaled <- BLM_erbr_lag
BLM_erbr_lag_scaled$StageName <- "dead"
BLM_erbr_lag_scaled$StageName[BLM_erbr_lag_scaled$Stage == 0] <- "vegetative"
BLM_erbr_lag_scaled$StageName[BLM_erbr_lag_scaled$Stage == 1] <- "reproductive"

table(BLM_erbr_lag_scaled$SiteName,BLM_erbr_lag_scaled$Year, BLM_erbr_lag_scaled$StageName)

## Can't seem to get rid of "dead" in first year 2018 of Big Bend
# BLM_erbr_lag_scaled <- BLM_erbr_lag_scaled[!(BLM_erbr_lag_scaled$Year == 2018 & BLM_erbr_lag_scaled$StageName == "dead" & BLM_erbr_lag_scaled$SiteName == "BigBend_BLM"),]
# table(BLM_erbr_lag_scaled$SiteName[BLM_erbr_lag_scaled$Year == 2018 & BLM_erbr_lag_scaled$StageName == "dead"])
```

Format for popbio projection.matrix  
Use the lag from BLM_erbr_lag to determine the previous time with data to base the missing stage off of
```{r}

# BLM_erbr_lag_scaled <- BLM_erbr_lag_scaled[,c("SiteName","Site","Year","Tag","Stage","StageName","surv","lagsrtstg",
#                                               "Tmean.summer", "Ppt.summer","Tmean.winter", "Ppt.winter", 
#                                               "Tmean.fall",    "Ppt.fall")]
head(BLM_erbr_lag_scaled)
BLM_erbr_lag_scaled <- BLM_erbr_lag_scaled[,c("SiteName","Site","Year","Tag","Stage","StageName", "surv", "lagsrtstg",
                                              "meanTmean.summer","meanTmean.fall","meanTmean.winter",
                                              "TotPpt.summer","TotPpt.fall","TotPpt.winter")]
# BLM_erbr_lag_scaled$Stage <- as.factor(BLM_erbr_lag_scaled$Stage)
# BLM_erbr_lag_scaled$surv <- as.factor(BLM_erbr_lag_scaled$surv)

BLM_erbr_scaled <- subset(merge(BLM_erbr_lag_scaled, BLM_erbr_lag_scaled, by = c("SiteName","Site","Tag")), 
                          sort=FALSE, Year.x == Year.y - 1)
head(BLM_erbr_scaled)

```


# just use the models from DBG data 
Probability of reproducing: 
     i.e. stage_t ~ stage_t-1 (size for DBG) + winter precip_t + winter temp_t + summer precip_t
          stage.y ~ stage.x                  + Ppt.winter.y      + Tmean.winter.y + Ppt.summer.y             
```{r}
# BLM_erbr_scaled has .x and next year .y
# BLM_erbr_lag_scaled is just a row per year and tag

# modelimpute <- glmer(Stage.y ~ Stage.x + Ppt.winter.y + Tmean.winter.x + Ppt.summer.y +
modelimpute <- glmer(Stage.y ~ Stage.x + TotPpt.winter.y + meanTmean.winter.y + TotPpt.summer.y +
                       (1 | Year.y) + (1 | SiteName), 
                     # data = BLM_erbr_scaled_naomit, # BLM_erbr_naomit, 
                     data = BLM_erbr_scaled[complete.cases(BLM_erbr_scaled),],
                     family = binomial(link = "logit"), 
                     na.action = na.fail)

summary(modelimpute)
```

```{r}
# The precip and temperature a full year before 
TempWinter <- ggplot(BLM_erbr_scaled[complete.cases(BLM_erbr_scaled),], # BLM_erbr_scaled_naomit, 
                     aes(meanTmean.winter.y, Stage.y, colour = as.factor(Stage.x)))+
  geom_point()+
  geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE)+
  theme_bw()+
  scale_colour_discrete(name = expression(Stage[t-1]),
                        labels = c("Vegetative","Reproductive"))+
  ylab(expression(Stage[t]))+
  xlab(expression("Mean winter temperature"[t]))


# More likely to be reproductive as Ppt.summer increases when already reproductive previous census
PptSummer <- ggplot(BLM_erbr_scaled[complete.cases(BLM_erbr_scaled),], # BLM_erbr_scaled_naomit, 
                    aes(TotPpt.summer.y, Stage.y, colour = as.factor(Stage.x)))+
  geom_point()+
  geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE)+
  theme_bw()+
  scale_colour_discrete(name = expression(Stage[t-1]),
                        labels = c("Vegetative","Reproductive"))+
  ylab(expression(Stage[t]))+
  xlab(expression("Summer Precipitation"[t]))

PptWinter <- ggplot(BLM_erbr_scaled[complete.cases(BLM_erbr_scaled),], # BLM_erbr_scaled_naomit,
                    aes(TotPpt.winter.y, Stage.y, colour = as.factor(Stage.x)))+
  geom_point()+
  geom_smooth(method = "glm", method.args = list(family = "binomial"), se = FALSE)+
  theme_bw()+
  scale_colour_discrete(name = expression(Stage[t-1]),
                        labels = c("Vegetative","Reproductive"))+
  ylab(expression(Stage[t]))+
  xlab(expression("Winter Precipitation"[t]))


ggsave("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/2021_Eriogonum-brandegeei_integrated_figures/ImputeBLMdata.jpg",
       TempWinter/PptSummer/PptWinter,
width=120, height=240,units='mm', dpi=300)

```

```{r}
# Use the ones not merged yet
head(BLM_erbr_lag_scaled)
head(BLM_erbr_scaled)
head(BLM_erbr_newplts)
table(BLM_erbr_lag_scaled$lagsrtstg)

tags2impute <- unique(BLM_erbr_lag_scaled$Tag[BLM_erbr_lag_scaled$lagsrtstg > 0])

for(tt in tags2impute){
  
  imputeTag <- BLM_erbr_lag_scaled[BLM_erbr_lag_scaled$Tag == tt,]
  # last stage recorded
  # Last good year data through Years to impute
    years2impute <- imputeTag$Year[imputeTag$lagsrtstg > 0]-1
  # yy <- years2impute[2]  
  for(yy in years2impute) {
    # where stage.x is there, stage.y is missing
    Stage <- rbinom(n = 1, size = 1, 
                    prob = predict(modelimpute,
                                   newdata = BLM_erbr_scaled[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy,],
                                   type="response"))
    BLM_erbr_lag_scaled$Stage[BLM_erbr_lag_scaled$Tag == tt & BLM_erbr_lag_scaled$Year == yy+1] <- Stage
    BLM_erbr_scaled$Stage.y[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy] <-
      BLM_erbr_scaled$Stage.x[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy+1] <- Stage
    
    if(Stage == 1){
      BLM_erbr_lag_scaled$StageName[BLM_erbr_lag_scaled$Tag == tt & BLM_erbr_lag_scaled$Year == yy+1] <-
        BLM_erbr_scaled$StageName.y[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy] <-
        BLM_erbr_scaled$StageName.x[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy+1] <- "reproductive"
    } else {
      BLM_erbr_lag_scaled$StageName[BLM_erbr_lag_scaled$Tag == tt & BLM_erbr_lag_scaled$Year == yy+1] <- 
        BLM_erbr_scaled$StageName.y[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy] <-
        BLM_erbr_scaled$StageName.x[BLM_erbr_scaled$Tag == tt & BLM_erbr_scaled$Year.x == yy+1] <- "vegetative"
    }
  } # end sequential imputing
}

# table(BLM_erbr2$Stage.x, BLM_erbr2$Stage.y) 
table(BLM_erbr_scaled$Stage.x, BLM_erbr_scaled$Stage.y) 
BLM_erbr_scaled$StageName.x <- factor(BLM_erbr_scaled$StageName.x, 
                                      levels = c("vegetative","reproductive","dead"), ordered = TRUE)
BLM_erbr_scaled$StageName.y <- factor(BLM_erbr_scaled$StageName.y, 
                                      levels = c("vegetative","reproductive","dead"), ordered = TRUE)


# Fate, Stage
table(BLM_erbr_scaled$StageName.y, BLM_erbr_scaled$StageName.x)

BLM_erbr2 <- BLM_erbr_scaled
```





Use popbio to construct stage-structured projection matrices from transition tables
```{r}
head(BLM_erbr2) # now imputed missing data
head(BLM_erbr_newplts)
BLM_erbr2 <- merge(BLM_erbr2, BLM_erbr_newplts, by.x = c("SiteName","Site","Year.x"), by.y = c("SiteName","Site","Year"))
# Stage 0 == vegetative; 1 == reproductive

BLM_MPM <- BLM_erbr2 
names(BLM_MPM) <- c("SiteName","Site","Year","Tag","StageNum","Stage",
                    "surv","lag",names(BLM_MPM)[9:14],"Year1","FateNum","Fate","surv1",
                    "lag1",names(BLM_MPM)[20:29])

# Add anonymous reproduction based on the proportional reproductive outputs of flowering plants and total number of seedlings at the end of the projection interval 
# BLM_newplts <- read.csv("C:/Users/DePrengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Eriogonum brandegeei/2020_Eriogonum-brandegeei_AprilGoebl_PVA/ErBr_scripts_May2021/erbr_BLM_newplts.csv")
# BLM_MPM <- merge(BLM_MPM, BLM_newplts, by = c("Year","SiteName","Site"))

# Assign random number of fruit per reproductive individual; NAs will produce errors
BLM_MPM$fruit <- sapply(1:nrow(BLM_MPM), function(rw){
  if(BLM_MPM$StageNum[rw] == 1 && !is.na(BLM_MPM$StageNum[rw])){
    # From DBG, amount of fruit depends on Summer precipitation
    max(1, rpois(1,20+(10*BLM_MPM$TotPpt.summer.x[rw]))) 
    } else {
      0
      }
  })

hist(BLM_MPM$fruit[BLM_MPM$StageNum == 1])
table(BLM_MPM$fruit)

ggplot(BLM_MPM[BLM_MPM$StageNum == 1,], aes(fruit))+
  geom_histogram()+
  theme_bw()

BLM_MPM[is.na(BLM_MPM$fruit) == TRUE,] # BLM_MPM$StageNum == 1 & 
max(BLM_MPM$fruit)

head(BLM_MPM)
# if vegetative then no fruit
table(BLM_MPM$StageNum, BLM_MPM$fruit)

ggplot(BLM_MPM[BLM_MPM$fruit > 0,], aes(Ppt.summer.x, fruit, colour = SiteName))+
  geom_jitter(height = 0, width = 0.2, alpha = 0.2)+
  stat_smooth(method = "lm")+
  xlab("Summer Precipitation")


## count reproductive plants in year t and seedlings in year t+1
# splitdf <- split(BLM_MPM, list(BLM_MPM$Site, BLM_MPM$Year), drop = TRUE) 
# x <- splitdf[[35]] # 2 new plants
# x <- splitdf[[119]]

# BLM_erbr2$Tag[BLM_erbr2$StageName.x == "dead" & BLM_erbr2$StageName.y != "dead"]
# BLM_erbr2[BLM_erbr2$Tag == "BB_10_152",]

BLM_reproplts <- lapply(split(BLM_MPM, list(BLM_MPM$Site, BLM_MPM$Year), drop = TRUE ), function(x){
  # x <- x[!is.na(x$Stage),]
  repro <- sum(x$StageNum, na.rm = TRUE)
  if(is.na(x$num.newPlts1[1]) ==  TRUE){
    x$seedling <- 0
  } else {
    x$seedling <- x$fruit / sum(x$fruit, na.rm = TRUE)*x$num.newPlts1[1] # anonymous contribution
  }
  
  # transition frequency table for T matrix
  tf <- table(x$Fate, x$Stage)
  T.mat <- prop.table(tf,2)[-3,-3] # remove "dead" fate and stage
  T.mat[is.nan(T.mat)] <- 0
  
  fert <- tapply(x$seedling, x$Stage, mean)[-3]
  print(fert)
  fert[is.na(fert)] <- 0
  F.mat <- T.mat * 0
  F.mat[1,] <- fert
  
  A.mat <- T.mat + F.mat
  A.mat

})


table(BLM_MPM$Site)
head(BLM_reproplts)

lambda(mean(BLM_reproplts[grep("BB", names(BLM_reproplts))])) # , na.rm = TRUE
lambda(mean(BLM_reproplts[grep("CG", names(BLM_reproplts))]))
lambda(mean(BLM_reproplts[grep("DGBLM", names(BLM_reproplts))]))
lambda(mean(BLM_reproplts[grep("GPQ", names(BLM_reproplts))]))

var(unlist(lapply(BLM_reproplts[grep("BB", names(BLM_reproplts))], function(mat){ 
  lambda(mat)
  })))
var(unlist(lapply(BLM_reproplts[grep("CG", names(BLM_reproplts))], function(mat){ 
  lambda(mat)
  })))
var(unlist(lapply(BLM_reproplts[grep("DGBLM", names(BLM_reproplts))], function(mat){ 
  lambda(mat)
  })))
var(unlist(lapply(BLM_reproplts[grep("GPQ", names(BLM_reproplts))], function(mat){ 
  lambda(mat)
  })))

# BLM_reproplts$AU[BLM_reproplts$S] <- "Salida.North"
# BLM_reproplts$AU[]


lambda(mean(BLM_reproplts[grep("BB|DGBLM", names(BLM_reproplts))])) # , na.rm = TRUE
lambda(mean(BLM_reproplts[grep("CG|GPQ", names(BLM_reproplts))]))

var(unlist(lapply(BLM_reproplts[grep("BB|DGBLM", names(BLM_reproplts))], function(mat) lambda(mat)))) # , na.rm = TRUE
var(unlist(lapply(BLM_reproplts[grep("CG|GPQ", names(BLM_reproplts))], function(mat) lambda(mat))))



```


