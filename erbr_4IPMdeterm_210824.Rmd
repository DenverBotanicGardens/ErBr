---
title: "erbr_IPM_deterministic"
author: "April Goebl"
date: "3/9/2021"
output: html_document
---

```{r setup, include=FALSE}

rm(list=ls())
knitr::opts_chunk$set(echo = FALSE)
library(MASS)
library(dplyr)
library(matrixStats)
library(corrplot)
library(rgl)
library(lattice)
library(viridis) 
library(car)

```



```{r, echo=FALSE}

## LOAD DATA 
erbr <- read.csv("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbr_TagClust_210510.csv", header=TRUE)
clim30yr <- read.csv("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbr_climData3seas30yr_210209.csv", header=TRUE)


## MODIFY DATA
## Check structure of, and modify variables as needed 
#str(erbr)
erbr$Year <- as.factor(erbr$Year)


## Add t+1 climate, sz, & tag into erbr data 
erbr <- erbr %>% mutate(TagNew1=lead(TagNew), RosNew1=lead(RosNew))  
erbr <- erbr %>% mutate(PptFall1=lead(PptFall), PptWinter1=lead(PptWinter), PptSummer1=lead(PptSummer),
                        TempFall1=lead(TempFall), TempWinter1=lead(TempWinter), TempSummer1=lead(TempSummer))

erbr <- erbr[which(erbr$TagNew == erbr$TagNew1),]  #Remove lines with mis-matched individuals 

```




## PLOT HISTORIACAL AND STUDY PERIOD CLIMATE DATA 
```{r}

climStudyYrs <- clim30yr[clim30yr$Year>2003 & clim30yr$Year<2019,]


par(mfrow=c(1,2))                     
par(pty="s")
par(mar=c(4.3,4.5,2,2))
plot(clim30yr$Tot_winter_ppt, clim30yr$Tot_summer_ppt, pch=16, ylab="Summer precipitation (mm)",
     xlab="Winter precipitation (mm)", cex.lab=1.6, cex.axis=1.3, cex=1.25)
points(climStudyYrs$Tot_winter_ppt, climStudyYrs$Tot_summer_ppt, pch=16, col="red")

par(pty="s")
par(mar=c(4.3,4.5,2,2))
plot(clim30yr$Tot_winter_ppt, clim30yr$Mean_winter_temp, pch=16, ylab="Winter temperature (C)",
     xlab="Winter precipitation (mm)", cex.lab=1.6, cex.axis=1.3, cex=1.25)
points(climStudyYrs$Tot_winter_ppt, climStudyYrs$Mean_winter_temp, pch=16, col="red")



## ** LOOK AT ADDITIONAL CLIM VARS AND/ OR PLOT ANNUAL PRECIP..? ** 

```



## SET UP FOR IPM
```{r}

## SPECIFIY MIN AND MAX PLANT SIZE
minsize <- 1
maxsize <- (max(erbr$RosNew, na.rm=TRUE)) 


## FOR MEDIAN SIZE ESTIMATION
## From Dan's bistorts to guppies code 
##new size density estimation for median size estimation
pdfsz=density(erbr$RosNew, n=1024, cut=0, na.rm=TRUE) 
pdfsz2=cbind(pdfsz$x,pdfsz$y)
## This is a set of smoothed values that can then be used with weightedMedian in the matrixStats package to get a 'good' median for each class.

```




## LOAD MODEL OUTPUT FROM JAGS RUN
```{r}

## Load chains for all parameters
#jags.mod <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbr_JAGSmod_c3t10s30b10_noYRE_210613.rds")
#jags.mod <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/growsurvrepromod_210308.c3t3s10b2.rds")
#chains <- jags.mod$mcmc
#chains <- bind_rows(lapply(chains, as.data.frame))


## Save 'chains' variable for easy re-loading
#saveRDS(chains, file="chains.c3t10s30b10_noYRE_210613.rds")
chains <- readRDS("chains.c3t10s30b10_noYRE_210613.rds")

```





## IPM - COMPARE OUTPUT BASED ON DIFFERENT NUMBERs OF SIZE BINS
```{r}

## DEFINE NUMBER OF SIZE BINS TO USE 
## For determining appropriate number of bins
bin.num <- c(5,10,20,30,40,45,50,55,60,65,70,75,80,90,100)  



## CALCULATE MEDIAN PARAMETER VALUES (exclude param uncertainty here)
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)



## CALCULATE MEAN CLIMATE CONDITIONS 
climStudyYrs <- clim30yr[clim30yr$Year>2003 & clim30yr$Year<2019,] #Subset to keep yrs of study period only
climMeans <- colMeans(climStudyYrs)



## CREATE VARIABLES TO STORE OUTPUT 
column.names <- c("BIN.NUM","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=length(bin.num), ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$BIN.NUM <- rep(bin.num)



## LOOP OVER DIFFERENT NUMBERS OF BINS
for (bb in 1:length(bin.num)) {
  
## Improved method of finding median size/ bin mids (code from Dan)
  vec.bin = c(minsize, minsize+1:bin.num[bb]*(maxsize-minsize)*(1/bin.num[bb])) 
  ## Do this block to make medians the focal estimated size for each cat
  binmids = rep(NA, length(vec.bin)-1)
      
  for(jj in 1:(length(vec.bin)-1)) {
      ## Set limits for subset according to bin breaks
      bounds <- c(vec.bin[jj], vec.bin[jj+1])
      ## Subset data according to bounds
      subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
      binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
      }
    
  n.bin = length(binmids)
  truebinsizes = n.bin  


  ## Initialize variable with input data for predictions
  in.data <- as.data.frame(binmids) 
  colnames(in.data) <- "RosNew"

        
        ## Plug in median param vals, mean climate and selected size predictor values for sz classes/ loop into model formulas
        ## Exclude random trasenct effects here (alternatively, could try mean values)
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) 
                          + medParams$grwth_TempFallCoef*climMeans["Mean_fall_temp"]
                          + medParams$grwth_TempSummerCoef*climMeans["Mean_summer_temp"]
                          + medParams$grwth_TempWinterCoef*climMeans["Mean_winter_temp"]
                          + medParams$grwth_PptFallCoef*climMeans["Tot_fall_ppt"]
                          + medParams$grwth_PptSummerCoef*climMeans["Tot_summer_ppt"]
                          + medParams$grwth_PptWinterCoef*climMeans["Tot_winter_ppt"])

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*in.data$RosNew + 
                                medParams$surv_PptWinterCoef*climMeans["Tot_winter_ppt"] + 
                                medParams$surv_TempWinterCoef*climMeans["Mean_winter_temp"] +
                                medParams$surv_TempSummerCoef*climMeans["Mean_summer_temp"] + 
                                medParams$surv_TempFallCoef*climMeans["Mean_fall_temp"])))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                                      medParams$reproyesno_PptFallCoef*climMeans["Tot_fall_ppt"] +
                                      medParams$reproyesno_PptSummerCoef*climMeans["Tot_summer_ppt"] +
                                      medParams$reproyesno_TempFallCoef*climMeans["Mean_fall_temp"] +
                                      medParams$reproyesno_TempSummerCoef*climMeans["Mean_summer_temp"] +
                                      medParams$reproyesno_TempWinterCoef*climMeans["Mean_winter_temp"]))) 

        ## Reroduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                          medParams$repro_PptFallCoef*climMeans["Tot_fall_ppt"] +
                          medParams$repro_PptSummerCoef*climMeans["Tot_summer_ppt"] +
                          medParams$repro_TempSummerCoef*climMeans["Mean_summer_temp"] +
                          medParams$repro_TempWinterCoef*climMeans["Mean_winter_temp"] +
                          medParams$repro_TempFallCoef*climMeans["Mean_fall_temp"])

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg <- 1            #Change ros size to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg) + 
                                medParams$surv_PptWinterCoef*climMeans["Tot_winter_ppt"] + 
                                medParams$surv_TempWinterCoef*climMeans["Mean_winter_temp"] +
                                medParams$surv_TempSummerCoef*climMeans["Mean_summer_temp"] + 
                                medParams$surv_TempFallCoef*climMeans["Mean_fall_temp"])))
    
        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))

        
        ## From Dan's code
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## Growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #Growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling surv in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.numSdlg                         #First row (new seedlings)
    
        lam.out.template[bb,2] <- Re(eigen(mx)$values[1])         #Calculate & store lambda
    
}  #End bb loop


## Look at results
lam.out.template

```




## IPM TO GET DETERMINISTIC LAMBDA, VRS, AND MATRICES FOR EACH TRANSECT & YEAR OF STUDY PERIOD
```{r}

## IPM ------------------------------
bin.num <- 50  #Define number of bins 

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
## Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  




## CREATE VARIABLES FOR OUTPUT
clim30yr$Year <- as.factor(clim30yr$Year)
clim30yr <- clim30yr %>% rename(PptFall=Tot_fall_ppt, PptWinter=Tot_winter_ppt, PptSummer=Tot_summer_ppt,
                   TempFall=Mean_fall_temp, TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp)
clim30yr <- clim30yr %>% mutate(PptFall1=lead(PptFall), PptWinter1=lead(PptWinter), PptSummer1=lead(PptSummer),
                   TempFall1=lead(TempFall), TempWinter1=lead(TempWinter), TempSummer1=lead(TempSummer))


params <- 1000  #Number of iterations for param uncertainty eg. 1000
#num.year <- length(unique(erbr$Year))
num.year <- length(unique(clim30yr$Year))-1
num.transect <- length(unique(erbr$TransectNew))
#list.year <- sort(unique(erbr$Year))
list.year <- sort(unique(clim30yr$Year[1:(nrow(clim30yr)-1)]))
list.transect <- sort(unique(erbr$TransectNew))

## Make dataframes to hold output
## Want lambda estimate for each parameter set, year, and transect 
column.names <- c("PARAM","YEAR","TRANSECT","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*params, ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew))
#lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=num.transect)
lam.out.template$YEAR <- rep(sort(clim30yr$Year[1:(nrow(clim30yr)-1)]), each=num.transect)
lam.out.template$PARAM <- rep(1:params, each=(nrow(lam.out.template)/params))
lam.out.param <- NULL      #Variable to store final lambda outputs

column.names.vrs <- c("PARAM","YEAR","TRANSECT","SZ","GRWTH","GRWTH_VAR","SURV","REPRO_PROB","REPRO_AMT","NEW_PLTS")
vrs.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*params*bin.num, ncol=length(column.names.vrs)))
colnames(vrs.template) <- column.names.vrs
vrs.template$SZ <- rep(binmids)
vrs.template$TRANSECT <- rep(unique(erbr$TransectNew), each=length(binmids))
#vrs.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect*length(binmids)))
vrs.template$YEAR <- rep(sort(clim30yr$Year[1:(nrow(clim30yr)-1)]), each=(num.transect*length(binmids)))
vrs.template$PARAM <- rep(1:params, each=(nrow(vrs.template)/params))
vrs.param <- NULL          #Variable to store final vital rate outputs

mx.out.list <- NULL        #List variable to store all matrices


## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"


## List of random numbers that corresponds to a set of parameter values to be used in each iteration of param loop
randVals.param <- sample(1:nrow(chains), size=params, prob=NULL, replace=FALSE)



## Loop for parameter uncertainty
for (pp in 1:params) {
  template.param <- subset(lam.out.template, PARAM==pp)  #Subset output template by param in parameter loop 
  lam.out.yr <- NULL                                     #Reset output variable each year loop
  temp.vrs.param <- subset(vrs.template, PARAM==pp)  
  vrs.yr <- NULL  
  
  ## Randomly select set of param values for all vital rates from chain list 
  selParams <- chains[randVals.param[pp],]
  
  ## Separate out transect & yr random intercepts 
  randTrans.grwth <- names(selParams)[grep("grwth_Transect_random",names(selParams))]
  randTrans.surv <- names(selParams)[grep("surv_Transect_random",names(selParams))]
  randTrans.reproYesNo <- names(selParams)[grep("reproyesno_Transect_random",names(selParams))]
  randTrans.repro <- names(selParams)[grep("repro_Transect_random",names(selParams))]
  


  ## Loop over years and transects
  for (yy in 1:num.year) {
    template.yr <- subset(template.param, YEAR==list.year[yy])  #Subset output template based on yr in yr loop
    temp.vrs.yr <- subset(temp.vrs.param, YEAR==list.year[yy])
    vrs.trans <- NULL
    
    for (tt in 1:num.transect) {
      temp.vrs.trans <- subset(temp.vrs.yr, TRANSECT==list.transect[tt])  #Subset vital rate output template based on transect

      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(clim30yr$PptSummer[clim30yr$Year==list.year[yy]]), 
                 PptWinter=unique(clim30yr$PptWinter[clim30yr$Year==list.year[yy]]), 
                 PptFall=unique(clim30yr$PptFall[clim30yr$Year==list.year[yy]]), 
                 TempSummer=unique(clim30yr$TempSummer[clim30yr$Year==list.year[yy]]), 
                 TempFall=unique(clim30yr$TempFall[clim30yr$Year==list.year[yy]]),
                 TempWinter=unique(clim30yr$TempWinter[clim30yr$Year==list.year[yy]]), 
                 PptSummer1=unique(clim30yr$PptSummer1[clim30yr$Year==list.year[yy]]), 
                 PptWinter1=unique(clim30yr$PptWinter1[clim30yr$Year==list.year[yy]]),
                 PptFall1=unique(clim30yr$PptFall1[clim30yr$Year==list.year[yy]]), 
                 TempFall1=unique(clim30yr$TempFall1[clim30yr$Year==list.year[yy]]),
                 TempSummer1=unique(clim30yr$TempSummer1[clim30yr$Year==list.year[yy]]), 
                 TempWinter1=unique(clim30yr$TempWinter1[clim30yr$Year==list.year[yy]]))
      
                 
        
        ## Plug selected param vals for given loop, predictor vals for given yr, transect, & sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(selParams$grwth_intercept + selParams$grwth_RosCoef*log(in.data$RosNew) 
                      + selParams$grwth_TempFallCoef*in.data$TempFall1 + selParams$grwth_TempSummerCoef*in.data$TempSummer1 
                      + selParams$grwth_TempWinterCoef*in.data$TempWinter1 + selParams$grwth_PptFallCoef*in.data$PptFall1
                      + selParams$grwth_PptSummerCoef*in.data$PptSummer1 + selParams$grwth_PptWinterCoef*in.data$PptWinter1
                      + as.numeric(selParams[randTrans.grwth[tt]])) 
        #pred.grwth[pred.grwth > maxsize] <- maxsize  #If predictions exceed bounds, change to max value

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(selParams$grwthvar_intercept + selParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(selParams$surv_intercept + selParams$surv_RosCoef*log(in.data$RosNew) + 
                     selParams$surv_PptWinterCoef*in.data$PptWinter1 + selParams$surv_TempWinterCoef*in.data$TempWinter1 +
                     selParams$surv_TempSummerCoef*in.data$TempSummer1 + selParams$surv_TempFallCoef*in.data$TempFall1 +
                     as.numeric(selParams[randTrans.surv[tt]]))))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(selParams$reproyesno_intercept + selParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           selParams$reproyesno_PptFallCoef*in.data$PptFall + selParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           selParams$reproyesno_TempFallCoef*in.data$TempFall + selParams$reproyesno_TempSummerCoef*in.data$TempSummer
                           + selParams$reproyesno_TempWinterCoef*in.data$TempWinter 
                           + as.numeric(selParams[randTrans.reproYesNo[tt]])))) 

        ## Reroduction (neg binom)
        pred.repro <- exp(selParams$repro_intercept + selParams$repro_RosCoef*log(in.data$RosNew) + 
                      selParams$repro_PptSummerCoef*in.data$PptSummer + selParams$repro_PptFallCoef*in.data$PptFall
                      + selParams$repro_TempFallCoef*in.data$TempFall + selParams$repro_TempSummerCoef*in.data$TempSummer
                      + selParams$repro_TempWinterCoef*in.data$TempWinter + as.numeric(selParams[randTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates
        

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(selParams$surv_intercept + selParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                                selParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + 
                                selParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 +
                                selParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + 
                                selParams$surv_TempFallCoef*in.dataSdlg$TempFall1 +
                                as.numeric(selParams[randTrans.surv[tt]]))))

        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(selParams$newplt_intercept + log(pred.repro))

        ## Store vital rate predictions
        temp.vrs.trans$GRWTH <- pred.grwth
        temp.vrs.trans$GRWTH_VAR <- pred.grwthVar
        temp.vrs.trans$SURV <- pred.surv
        temp.vrs.trans$REPRO_PROB <- pred.reproYesNo
        temp.vrs.trans$REPRO_AMT <- pred.repro
        temp.vrs.trans$NEW_PLTS <- pred.numSdlg
        vrs.trans <- rbind(vrs.trans, temp.vrs.trans)         #Combine VRs for all transects

   
        ## From Dan's code
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
    
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.reproYesNo * pred.numSdlg       #First row (new seedlings)
    
        template.yr[tt,4] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        mx.out.list[[length(mx.out.list) + 1]] <- mx
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, template.yr)     #Combine lambda values for all years 
        vrs.yr <- rbind(vrs.yr, vrs.trans)               #Combine vital rate values for all years 
        
  }    #End yy loop

  lam.out.param <- rbind(lam.out.param, lam.out.yr)      #Combine lambda values for all parameter values
  vrs.param <- rbind(vrs.param, vrs.yr)                  #Combine vital rate values for all parameter values

}    #End pp loop

```


```{r}

## SAVE OUTPUT
## Save lambda & vital rate output 
date <- as.character(220806) 
name <- as.character("P1k")
saveRDS(lam.out.param, file=paste("erbrLams_noYRE", name, date, sep="_"))
saveRDS(vrs.param, file=paste("erbrVRs_noYRE", name, date, sep="_"))


## Save list of matrices as an R object for use in stochastic lambda script 
## Name each matrix by it's parameter, year, and transect
paramYrTrans.comb <- lam.out.template[,1:3]
names(mx.out.list) <- paste(as.character(paramYrTrans.comb$YEAR), as.character(paramYrTrans.comb$TRANSECT), sep='_')
names(mx.out.list) <- paste(as.character(paramYrTrans.comb$PARAM), names(mx.out.list), sep="-")
names(mx.out.list) <- paste("p", names(mx.out.list), sep="")

date <- as.character(220806) 
name <- as.character("P1k")
saveRDS(mx.out.list, file=paste("erbrIPMmxList_noYRE", name, date, sep="_"))




## LOOK AT RESULTS
cols <- viridis(12)
par(mfrow=c(4,4))                      #Plot in 14 panels
par(mar=c(2,3.9,2,2), mgp = c(2.3, 1, 0))  

for (pp in 1:length(list.year)) {
  lam.yr <- subset(lam.out.param, YEAR==list.year[pp])
  boxplot(LAMBDA ~ TRANSECT, data=lam.yr, main=paste(as.character(list.year[pp])),ylim=c(0,1.4),
  xaxt='n',xlab=NA, cex=0.5, ylab="Lambda", cex.lab=1.6, cex.axis=1.4, font.main=1, cex.main=1.7,
  medlwd=1,col=cols)
  abline(h=1,col="red", lwd=0.75)
  text(6.5,-0.04, "Transect", pos=1, xpd=TRUE, cex=1.5)
}

```





## LOOK AT RELATIONSHIP B/W LAMBDA PER TRANSECT & NUM PLTS PER TRANSECT
```{r}

## To address the question of if poorer performing transects just have very few plants 

## Calc mean lambda in each year-transect combo
lam.means.yrTrans <- lam.out.param %>% group_by(YEAR, TRANSECT) %>% summarise(MEAN=mean(LAMBDA))

## Calc num of indiv plants per year and transect 
num.indivs <- erbr %>% group_by(Year, TransectNew) %>% summarise(numIndivs=sum(surv, na.rm=TRUE)) 
num.indivs <- rename(num.indivs, TRANSECT=TransectNew, YEAR=Year)

## Combine data
lams.nums <- dplyr::left_join(num.indivs, lam.means.yrTrans, by=c("YEAR","TRANSECT"))

## Remove years with no data
lams.nums <- lams.nums[lams.nums$YEAR!="2014",]
lams.nums <- lams.nums[lams.nums$YEAR!="2015",]
lams.nums <- lams.nums[lams.nums$YEAR!="2017",]


mod <- lmer(MEAN ~ numIndivs + (1|YEAR) + (1|TRANSECT), data=lams.nums)
summary(mod)
par(mar=c(5,5,2,2))  
plot(lams.nums$numIndivs, lams.nums$MEAN, xlab="Number of individuals", ylab="Deterministic lambda",
     pch=16, cex.lab=1.6, cex.axis=1.3)

```





## LOOK AT RELATIONSHIP B/W EACH VR AND PLT SIZE
```{r}

## In all years 
## ** Should this include NON-STUDY or just STUDY years? ***
vrs.mean <- vrs.param %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                           MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                           MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))


## In driest and wettest years 
#dats.clim <- erbr %>% dplyr::select(c(Year, PptWinter, PptSummer, TempWinter, TempSummer,PptFall,TempFall, 
#                                      PptWinter1, PptSummer1, TempWinter1, TempSummer1)) 
dats.clim <- clim30yr %>% dplyr::select(c(Year, PptWinter, PptSummer, TempWinter, TempSummer,PptFall,TempFall, 
                                      PptWinter1, PptSummer1, TempWinter1, TempSummer1)) 

clim <- unique(dats.clim)
clim <- clim[order(clim$Year),]
climSums <-  clim %>% rowwise() %>% mutate(PPT_SUM=sum(PptWinter,PptSummer,PptFall))  #Add over 3 seasons for annual totals
min.ppt <- climSums$Year[which.min(climSums$PPT_SUM)] #2011
max.ppt <- climSums$Year[which.max(climSums$PPT_SUM)] #2015

## Subset lambdas by wettest and driest year 
vrs.minPpt <- subset(vrs.param, YEAR==min.ppt)
vrs.maxPpt <- subset(vrs.param, YEAR==max.ppt)

vrs.minPpt.mean <- vrs.minPpt %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
vrs.maxPpt.mean <- vrs.maxPpt %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))


## ** ADD HOTTEST AND COOLEST YEARS TOO? **


## Plot results 
par(mfrow=c(2,2))                            #Plot in 4 panels
par(mar=c(6.2,5.5,3,3), mgp = c(2.5, 1, 0))  #bottom, left, top, and right

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_GRWTH, xlab="Plant size in t (rosette number)",ylim=c(0,100), 
     ylab="Plant size in t+1\n(rosette number)", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25)
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_GRWTH, col="red",lwd=2)
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_GRWTH, col="dodgerblue",lwd=2)

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_SURV, xlab="Plant size in t (rosette number)", 
     ylab="Survival probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25,ylim=c(0.8,1))
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_SURV, col="red",lwd=2)
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_SURV, col="dodgerblue",lwd=2)

legend("bottom", c("All", "Wet", "Dry"), col=c("black","dodgerblue","red"),lwd=2,cex=1.35,
       inset=c(-0.4,-0.49), xpd=TRUE, horiz=TRUE, bty="n",seg.len=1)

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROPROB, xlab="Plant size in t (rosette number)", 
     ylab="Reproduction probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25,ylim=c(0,1.05))
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROPROB, col="red",lwd=2)
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROPROB, col="dodgerblue",lwd=2)

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROAMT,xlab="Plant size in t (rosette number)",ylim=c(0,150), 
     ylab="Reproduction amount\n(inflorescence number)", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25)
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROAMT, col="red",lwd=2)
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROAMT, col="dodgerblue",lwd=2)


```





## IMPORTANCE OF EACH VR TO LAMBDA - VITAL RATE ELASTICITIES
```{r}

## IPM

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
##Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  



## CALCULATE MEDIAN PARAMETER VALUES 
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)

## Separate out transect & year random intercepts 
medTrans.grwth <- names(medParams)[grep("grwth_Transect_random",names(medParams))]
medTrans.surv <- names(medParams)[grep("surv_Transect_random",names(medParams))]
medTrans.reproYesNo <- names(medParams)[grep("reproyesno_Transect_random",names(medParams))]
medTrans.repro <- names(medParams)[grep("repro_Transect_random",names(medParams))]





## CREATE VARIABLES FOR OUTPUT 
num.year <- length(unique(erbr$Year))
num.transect <- length(unique(erbr$TransectNew))
list.year <- sort(unique(erbr$Year))
list.transect <- sort(unique(erbr$TransectNew))


## Perturbation amount
pert.amt <- 0.99 

## Make matrices to hold output
column.names <- c("YEAR","TRANSECT","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect, ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew))
lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect))

lam.out.yr <- NULL                                   
lam.out.yr.surv <- NULL
lam.out.yr.grwth <- NULL                                   
lam.out.yr.numSdlg <- NULL



## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"

 

## Loops for year and transect
for (yy in 1:num.year) {
    template.yr <- subset(lam.out.template, YEAR==list.year[yy])  
    template.yr.surv <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.grwth <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.reproYesNo <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.repro <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.numSdlg <- subset(lam.out.template, YEAR==list.year[yy])
    
    
    for (tt in 1:num.transect) {
      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(erbr$PptSummer[erbr$Year==list.year[yy]]), 
                 PptWinter=unique(erbr$PptWinter[erbr$Year==list.year[yy]]), 
                 PptFall=unique(erbr$PptFall[erbr$Year==list.year[yy]]), 
                 TempSummer=unique(erbr$TempSummer[erbr$Year==list.year[yy]]), 
                 TempFall=unique(erbr$TempFall[erbr$Year==list.year[yy]]),
                 TempWinter=unique(erbr$TempWinter[erbr$Year==list.year[yy]]), 
                 PptSummer1=unique(erbr$PptSummer1[erbr$Year==list.year[yy]]), 
                 PptWinter1=unique(erbr$PptWinter1[erbr$Year==list.year[yy]]),
                 PptFall1=unique(erbr$PptFall1[erbr$Year==list.year[yy]]), 
                 TempFall1=unique(erbr$TempFall1[erbr$Year==list.year[yy]]),
                 TempSummer1=unique(erbr$TempSummer1[erbr$Year==list.year[yy]]), 
                 TempWinter1=unique(erbr$TempWinter1[erbr$Year==list.year[yy]]))
        
        
        ## Plug selected param vals for given loop, and selected predictor values for given year, transect, and sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) + medParams$grwth_TempFallCoef*in.data$TempFall1
                      + medParams$grwth_TempSummerCoef*in.data$TempSummer1 + medParams$grwth_TempWinterCoef*in.data$TempWinter1
                      + medParams$grwth_PptFallCoef*in.data$PptFall1 + medParams$grwth_PptSummerCoef*in.data$PptSummer1
                      + medParams$grwth_PptWinterCoef*in.data$PptWinter1 + as.numeric(medParams[medTrans.grwth[tt]])) 

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.data$RosNew) + 
                                medParams$surv_PptWinterCoef*in.data$PptWinter1 + 
                                medParams$surv_TempWinterCoef*in.data$TempWinter1 +
                                medParams$surv_TempSummerCoef*in.data$TempSummer1 + 
                                medParams$surv_TempFallCoef*in.data$TempFall1 +
                                as.numeric(medParams[medTrans.surv[tt]]))))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           medParams$reproyesno_PptFallCoef*in.data$PptFall + medParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           medParams$reproyesno_TempFallCoef*in.data$TempFall + medParams$reproyesno_TempSummerCoef*in.data$TempSummer +
                           medParams$reproyesno_TempWinterCoef*in.data$TempWinter + as.numeric(medParams[medTrans.reproYesNo[tt]])))) 

        ## Reroduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                      medParams$repro_PptFallCoef*in.data$PptFall + medParams$repro_PptSummerCoef*in.data$PptSummer +
                      medParams$repro_TempWinterCoef*in.data$TempWinter + medParams$repro_TempSummerCoef*in.data$TempSummer
                      + medParams$repro_TempFallCoef*in.data$TempFall + as.numeric(medParams[medTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                         medParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + 
                         medParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 +
                         medParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + 
                         medParams$surv_TempFallCoef*in.dataSdlg$TempFall1 +
                         as.numeric(medParams[medTrans.surv[tt]]))))
    
        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))
        pred.fec <- pred.reproYesNo * pred.numSdlg
        
        
    
        ## NON-PERTURBED ESTIMATES
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.yr[tt,3] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect

        
        
        ##SURVIVAL PERTURBATION
        pred.surv.pert <- pred.surv * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv.pert,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.yr.surv[tt,3] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        
        
        
        ##GROWTH PERTURBATION
        pred.grwth.pert <- pred.grwth * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth.pert[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                       #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                                  #First row (new seedlings)
    
        template.yr.grwth[tt,3] <- Re(eigen(mx)$values[1])             #Calculate lambda & store for each transect
        
      
        
        ##FECUNDITY PERTURBATION (PROB REPRO, REPRO AMT, AND NUM SEEDLING)
        pred.fec.pert <- pred.fec * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                                #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec.pert                                      #First row (new seedlings)
    
        template.yr.numSdlg[tt,3] <- Re(eigen(mx)$values[1])                    #Calculate lambda & store for each transect
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, template.yr)                                      #Combine lambda values for all years 
        lam.out.yr.surv <- rbind(lam.out.yr.surv, template.yr.surv)                       #Combine lambda values for all years 
        lam.out.yr.grwth <- rbind(lam.out.yr.grwth, template.yr.grwth)                    #Combine lambda values for all years 
        lam.out.yr.numSdlg <- rbind(lam.out.yr.numSdlg, template.yr.numSdlg)              #Combine lambda values for all years 
  }    #End yy loop

  



## CALCULATE AND PLOT ELASTICITIES
lam.out.yr.surv$FRAC.DIFF <- (lam.out.yr.surv$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.surv$ELAS <- lam.out.yr.surv$FRAC.DIFF / -0.01

lam.out.yr.grwth$FRAC.DIFF <- (lam.out.yr.grwth$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.grwth$ELAS <- lam.out.yr.grwth$FRAC.DIFF / -0.01

lam.out.yr.numSdlg$FRAC.DIFF <- (lam.out.yr.numSdlg$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.numSdlg$ELAS <- lam.out.yr.numSdlg$FRAC.DIFF / -0.01

mean(lam.out.yr.grwth$ELAS)
mean(lam.out.yr.surv$ELAS)
mean(lam.out.yr.numSdlg$ELAS)


## Plot results 
## Boxplots
par(mfrow=c(1,3))                            
par(mar=c(4,5,2,3), mgp = c(2.6, 1, 0))      #bottom, left, top, and right
boxplot(lam.out.yr.grwth$ELAS, xlab="Growth", ylab="Elasticity",
     cex.lab=1.7, cex.axis=1.4, cex=0.35, ylim=c(0,1))
boxplot(lam.out.yr.surv$ELAS, xlab="Survival", ylab="Elasticity",
     cex.lab=1.7, cex.axis=1.4, cex=0.35, ylim=c(0,1))
boxplot(lam.out.yr.numSdlg$ELAS, xlab="Fecundity", 
     ylab="Elasticity",cex.lab=1.7, cex.axis=1.4, cex=0.5, ylim=c(0,1))

```




## IMPORTANCE OF EACH VR TO LAMBDA - SIZE-CLASS SPECIFIC ELASTICITIES
```{r}

## IPM

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
##Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  




## CALCULATE MEDIAN PARAMETER VALUES 
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)

## Separate out transect random intercepts 
medTrans.grwth <- names(medParams)[grep("grwth_Transect_random",names(medParams))]
medTrans.surv <- names(medParams)[grep("surv_Transect_random",names(medParams))]
medTrans.reproYesNo <- names(medParams)[grep("reproyesno_Transect_random",names(medParams))]
medTrans.repro <- names(medParams)[grep("repro_Transect_random",names(medParams))]





## CREATE VARIABLES FOR OUTPUT 
num.year <- length(unique(erbr$Year))
num.transect <- length(unique(erbr$TransectNew))
list.year <- sort(unique(erbr$Year))
list.transect <- sort(unique(erbr$TransectNew))


## Perturbation amount
pert.amt <- 0.99 

## Make matrices to hold output
column.names <- c("YEAR","TRANSECT","SZ_CLASS","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*(n.bin), ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$SZ_CLASS <- rep(1:n.bin)
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew), each=n.bin)
lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect*n.bin))

lam.out.yr <- NULL                #Reset output variable for year loop if doing param loop
lam.out.yr.surv <- NULL
lam.out.yr.grwth <- NULL                                   
lam.out.yr.reproYesNo <- NULL
lam.out.yr.repro <- NULL                                   
lam.out.yr.numSdlg <- NULL


## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"


## Loops for year and transect
  for (yy in 1:num.year) {
    template.yr <- subset(lam.out.template, YEAR==list.year[yy])  
    template.yr.surv <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.grwth <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.reproYesNo <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.repro <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.numSdlg <- subset(lam.out.template, YEAR==list.year[yy])
    
    lam.out.trans <- NULL 
    lam.out.trans.surv <- NULL
    lam.out.trans.grwth <- NULL
    lam.out.trans.reproYesNo <- NULL
    lam.out.trans.numSdlg <- NULL

    
    for (tt in 1:num.transect) {
      template.trans <- subset(template.yr, TRANSECT==list.transect[tt])  
      template.trans.surv <- subset(template.yr, TRANSECT==list.transect[tt])
      template.trans.grwth <- subset(template.yr, TRANSECT==list.transect[tt])
      template.trans.reproYesNo <- subset(template.yr, TRANSECT==list.transect[yy])
      template.trans.repro <- subset(template.yr, TRANSECT==list.transect[yy])
      template.trans.numSdlg <- subset(template.yr, TRANSECT==list.transect[tt])

      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(erbr$PptSummer[erbr$Year==list.year[yy]]), 
                 PptWinter=unique(erbr$PptWinter[erbr$Year==list.year[yy]]), 
                 PptFall=unique(erbr$PptFall[erbr$Year==list.year[yy]]), 
                 TempSummer=unique(erbr$TempSummer[erbr$Year==list.year[yy]]), 
                 TempFall=unique(erbr$TempFall[erbr$Year==list.year[yy]]),
                 TempWinter=unique(erbr$TempWinter[erbr$Year==list.year[yy]]), 
                 PptSummer1=unique(erbr$PptSummer1[erbr$Year==list.year[yy]]), 
                 PptWinter1=unique(erbr$PptWinter1[erbr$Year==list.year[yy]]),
                 PptFall1=unique(erbr$PptFall1[erbr$Year==list.year[yy]]), 
                 TempFall1=unique(erbr$TempFall1[erbr$Year==list.year[yy]]),
                 TempSummer1=unique(erbr$TempSummer1[erbr$Year==list.year[yy]]), 
                 TempWinter1=unique(erbr$TempWinter1[erbr$Year==list.year[yy]]))
        
        
        ## Plug selected param vals for given loop, and selected predictor values for given year, transect, and sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) 
                      + medParams$grwth_TempFallCoef*in.data$TempFall1 + medParams$grwth_TempSummerCoef*in.data$TempSummer1
                      + medParams$grwth_TempWinterCoef*in.data$TempWinter1 + medParams$grwth_PptFallCoef*in.data$PptFall1
                      + medParams$grwth_PptSummerCoef*in.data$PptSummer1 + medParams$grwth_PptWinterCoef*in.data$PptWinter1
                      + as.numeric(medParams[medTrans.grwth[tt]])) 
        
        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.data$RosNew) + 
                     medParams$surv_PptWinterCoef*in.data$PptWinter1 + medParams$surv_TempWinterCoef*in.data$TempWinter1 
                     + medParams$surv_TempSummerCoef*in.data$TempSummer1 + medParams$surv_TempFallCoef*in.data$TempFall1 
                     + as.numeric(medParams[medTrans.surv[tt]]))))
        
        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           medParams$reproyesno_PptFallCoef*in.data$PptFall + medParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           medParams$reproyesno_TempFallCoef*in.data$TempFall + medParams$reproyesno_TempSummerCoef*in.data$TempSummer +
                           medParams$reproyesno_TempWinterCoef*in.data$TempWinter + as.numeric(medParams[medTrans.reproYesNo[tt]])))) 
                                      
        
        ## Reproduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                      medParams$repro_PptFallCoef*in.data$PptFall + medParams$repro_PptSummerCoef*in.data$PptSummer +
                      medParams$repro_TempWinterCoef*in.data$TempWinter + medParams$repro_TempSummerCoef*in.data$TempSummer
                      + medParams$repro_TempFallCoef*in.data$TempFall + as.numeric(medParams[medTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                         medParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + medParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 
                         + medParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + medParams$surv_TempFallCoef*in.dataSdlg$TempFall1 
                         + as.numeric(medParams[medTrans.surv[tt]]))))

        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))
        pred.fec <- pred.reproYesNo * pred.numSdlg
        
   
        ## Loop over size classes 
        for (cc in 1:n.bin) {
        
          
        ## NON-PERTURBED ESTIMATES
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.trans[cc,4] <- Re(eigen(mx)$values[1])           #Calculate lambda & store for each transect

        
        
        ##SURVIVAL PERTURBATION
        pred.surv.pert <- pred.surv 
        pred.surv.pert[cc] <- pred.surv[cc] * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv.pert,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.trans.surv[cc,4] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        
        
        
        ##GROWTH PERTURBATION
        pred.grwth.pert <- pred.grwth 
        pred.grwth.pert[cc] <- pred.grwth[cc] * pert.amt 
        pred.grwth.pert[pred.grwth.pert > maxsize] <- maxsize 
        
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth.pert[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                       #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                                  #First row (new seedlings)
    
        template.trans.grwth[cc,4] <- Re(eigen(mx)$values[1])          #Calculate lambda & store for each transect
        
        
        
        ##FECUNDITY PERTURBATION (PROB REPRO, REPRO AMT, AND NUM SEEDLING)
        pred.fec.pert <- pred.fec 
        pred.fec.pert[cc] <- pred.fec[cc] * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                                 #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec.pert                                       #First row (new seedlings)
    
        template.trans.numSdlg[cc,4] <- Re(eigen(mx)$values[1])                  #Calculate lambda & store for each transect
        } # End cc (size class) loop
        
        lam.out.trans <- rbind(lam.out.trans, template.trans)  
        lam.out.trans.surv <- rbind(lam.out.trans.surv, template.trans.surv)                                      
        lam.out.trans.grwth <- rbind(lam.out.trans.numSdlg, template.trans.grwth) 
        lam.out.trans.numSdlg <- rbind(lam.out.trans.numSdlg, template.trans.numSdlg)                                      
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, lam.out.trans)                                      #Combine lambda vals for all yrs 
        lam.out.yr.surv <- rbind(lam.out.yr.surv, lam.out.trans.surv)                       #Combine lambda vals for all yrs 
        lam.out.yr.grwth <- rbind(lam.out.yr.grwth, lam.out.trans.grwth)                    #Combine lambda vals for all yrs 
        lam.out.yr.numSdlg <- rbind(lam.out.yr.numSdlg, lam.out.trans.numSdlg)              #Combine lambda vals for all yrs 
  }    #End yy loop

  


## ESTIMATE AND PLOT ELASTICITIES
## Calculate mean elasticities across years and transects
lam.mn <- lam.out.yr %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.grwth <- lam.out.yr.grwth %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.surv <- lam.out.yr.surv %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.numSdlg <- lam.out.yr.numSdlg %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))

lam.mn.grwth$FRAC.DIFF <- (lam.mn.grwth$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.grwth$ELAS <- lam.mn.grwth$FRAC.DIFF / -0.01
lam.mn.surv$FRAC.DIFF <- (lam.mn.surv$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.surv$ELAS <- lam.mn.surv$FRAC.DIFF / -0.01
lam.mn.numSdlg$FRAC.DIFF <- (lam.mn.numSdlg$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.numSdlg$ELAS <- lam.mn.numSdlg$FRAC.DIFF / -0.01


## Plot results 
par(mfrow=c(3,1))                            
par(mar=c(4,5,2,3))
barplot(lam.mn.grwth$ELAS ~ lam.mn.grwth$SZ_CLASS, xlab="Size class", ylab="Growth elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)
barplot(lam.mn.surv$ELAS ~ lam.mn.surv$SZ_CLASS, xlab="Size class", ylab="Survival elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)
barplot(lam.mn.numSdlg$ELAS ~ lam.mn.numSdlg$SZ_CLASS, xlab="Size class", ylab="Fecundity elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)

```





## HOW DOES LAMBDA VARY WITH CLIMATE?
```{r}

## LOOK AT RELATIONSHIP B/W LAMBDA & CLIMATE (USING 30 YRS OF DATA)
clim30yr <- clim30yr %>% rename(YEAR=Year)#, PptSummer=Tot_summer_ppt, PptWinter=Tot_winter_ppt, PptFall=Tot_fall_ppt,
#                                TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp, TempFall=Mean_fall_temp) 
clim30yr$YEAR <- as.factor(clim30yr$YEAR)

lam.out.param.comb <- rbind(lam.out.param)#, lam.out.param.nsy)
lam.out.param.comb <- dplyr::left_join(lam.out.param.comb, clim30yr, by="YEAR")




## Average across parameter uncertainty
lam.mean.yr <- lam.out.param.comb %>% group_by(YEAR) %>% dplyr::summarize(MEAN_LAM=mean(LAMBDA), PptSummer=mean(PptSummer),
                                                         TempWinter=mean(TempWinter), PptWinter=mean(PptWinter),
                                                         TempFall=mean(TempFall), PptFall=mean(PptFall), TempSummer=mean(TempSummer))

## 3-way interaction model with relevant clim variables (e.g. summer and winter precip, and winter temp)
lamVclim <- lm(MEAN_LAM ~ PptSummer * TempWinter * PptWinter, data=lam.mean.yr)
summary(lamVclim)
Anova(lamVclim)

summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$PptSummer))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$PptWinter))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$TempWinter))

par(mfrow=c(3,1))
plot(lam.mean.yr$PptSummer, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic lambda", xlab="Total summer precipitation (mm)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$PptWinter, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic lambda", xlab="Total winter precipitation (mm)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$TempWinter, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic lambda", xlab="Mean winter temperature (C)",
     cex.lab=1.5, cex.axis=1.25)

```