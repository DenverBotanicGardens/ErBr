---
title: "erbr_IPM_deterministic"
author: "April Goebl"
date: "3/9/2021"
output: html_document
---

```{r setup, include=FALSE}

rm(list=ls())
knitr::opts_chunk$set(echo = FALSE)
library(MASS)
library(dplyr)
library(matrixStats)
library(corrplot)
library(rgl)
library(lattice)
library(viridis) 
library(car)
library(coda)
library(lme4)

```



```{r, echo=FALSE}

## LOAD DATA 
erbr <- read.csv("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/ErBr/erbr_TagClust2022_20230408.csv", header=TRUE)
clim32yr <- read.csv("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbr_climData3seas32yr_221114.csv", header=TRUE)


## MODIFY DATA
## Check structure of, and modify variables as needed 
#str(erbr)
erbr$Year <- as.factor(erbr$Year)


## CHANGE NAMES OF CLIMATE COLUMNS ------------------------------------------------------------------
erbr <- rename(erbr, PptFall=Tot_fall_ppt, PptWinter=Tot_winter_ppt, PptSummer=Tot_summer_ppt,
               TempFall=Mean_fall_temp, TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp)

## Add t+1 climate, sz, & tag into erbr data 
erbr <- erbr %>% mutate(TagNew1=lead(TagNew), RosNew1=lead(RosNew))  
erbr <- erbr %>% mutate(PptFall1=lead(PptFall), PptWinter1=lead(PptWinter), PptSummer1=lead(PptSummer),
                        TempFall1=lead(TempFall), TempWinter1=lead(TempWinter), TempSummer1=lead(TempSummer))

erbr <- erbr[which(erbr$TagNew == erbr$TagNew1),]  #Remove lines with mis-matched individuals 

```




## PLOT HISTORIACAL AND STUDY PERIOD CLIMATE DATA 
```{r}

#climStudyYrs <- clim32yr[clim32yr$Year>2003 & clim32yr$Year<2019,]
climStudyYrs <- clim32yr[clim32yr$Year>2003 & clim32yr$Year<2023,]


par(mfrow=c(1,2))                     
par(pty="s")
par(mar=c(4.3,4.5,2,2))
plot(clim32yr$Tot_winter_ppt, clim32yr$Tot_summer_ppt, pch=16, ylab="Summer precipitation (mm)",
     xlab="Winter precipitation (mm)", cex.lab=1.4, cex.axis=1.05, cex=1.25)
points(climStudyYrs$Tot_winter_ppt, climStudyYrs$Tot_summer_ppt, pch=16, col="red")

par(pty="s")
par(mar=c(4.3,4.5,2,2))
plot(clim32yr$Tot_winter_ppt, clim32yr$Mean_winter_temp, pch=16, ylab="Winter temperature (C)",
     xlab="Winter precipitation (mm)", cex.lab=1.4, cex.axis=1.05, cex=1.25)
points(climStudyYrs$Tot_winter_ppt, climStudyYrs$Mean_winter_temp, pch=16, col="red")




## PLOT ANNUAL PRECIP AND MEAN ANNUAL TEMP  
clim32yr.tots <- clim32yr %>% mutate(Tot_ann_ppt=rowSums(across(Tot_fall_ppt:Tot_summer_ppt)),
                            Mean_ann_temp=rowMeans(across(Mean_fall_temp:Mean_summer_temp)))
climStudyYrs.tots <- clim32yr.tots[clim32yr.tots$Year>2003 & clim32yr.tots$Year<2023,]

par(mar=c(4.3,4.5,2,2))
par(pty="s")
plot(clim32yr.tots$Tot_ann_ppt, clim32yr.tots$Mean_ann_temp, pch=16, ylab="Mean annual temperature (°C)",
     xlab="Annual precipitation (mm)", cex.lab=1.4, cex.axis=1.05, cex=1.25)
points(climStudyYrs.tots$Tot_ann_ppt, climStudyYrs.tots$Mean_ann_temp, pch=16, col="red")




## PLOT SEASONAL VALUES FOR EACH YEAR
library(lattice)
library(tidyr)

## Precip
## Re-format data
ppt.stacked <- climStudyYrs %>% gather(season_ppt, ppt, Tot_fall_ppt:Tot_summer_ppt) 

ppt.fall <- ppt.stacked[which(ppt.stacked$season_ppt=="Tot_fall_ppt"),]
ppt.winter <- ppt.stacked[which(ppt.stacked$season_ppt=="Tot_winter_ppt"),]
ppt.summer <- ppt.stacked[which(ppt.stacked$season_ppt=="Tot_summer_ppt"),]

ppt.comb <- cbind(ppt.fall$ppt, ppt.winter$ppt, ppt.summer$ppt)
colnames(ppt.comb) <- c("fall_ppt","winter_ppt","summer_ppt")
rownames(ppt.comb) <- climStudyYrs$Year


## Temp
## Re-format data
temp.stacked <- climStudyYrs %>% gather(season_temp, temp, Mean_fall_temp:Mean_summer_temp) 

temp.fall <- temp.stacked[which(temp.stacked$season_temp=="Mean_fall_temp"),]
temp.winter <- temp.stacked[which(temp.stacked$season_temp=="Mean_winter_temp"),]
temp.summer <- temp.stacked[which(temp.stacked$season_temp=="Mean_summer_temp"),]

temp.comb <- cbind(temp.fall$temp, temp.winter$temp, temp.summer$temp)
colnames(temp.comb) <- c("fall_temp","winter_temp","summer_temp")
rownames(temp.comb) <- climStudyYrs$Year




## Plot 
#col=c("#f0bd27","#98d9e4","#51b364")
colz <- c("#d73027","#fc8d59","#91bfdb","#4575b4","#fdcb44","#fee090","grey60")

par(mfrow=c(2,1), mar=c(4.9,3.9,1.4,1.7)) #bottom, left, top, and right
barplot(t(temp.comb), beside=TRUE, ylab="Mean seasonal temperature (°C)", cex.names=0.8, col=c("black","grey50","grey80"), border=FALSE, las=1)
#text(1.5,-2.9, "X", cex=1,xpd=TRUE)
#arrows(1,-2.1,76,-2.1, lwd=3, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
#arrows(1,-2.4,40,-2.4, lwd=3, angle=90, code=3, length=0, col=colz[2],xpd=TRUE)
#arrows(1,-2.7,20,-2.7, lwd=3, angle=90, code=3, length=0, col=colz[5],xpd=TRUE)
#arrows(21,-3,40,-3, lwd=3, angle=90, code=3, length=0, col=colz[6],xpd=TRUE)
legend("bottom", c("Fall", "Winter", "Summer"), col=c("black","grey50","grey80"),
       cex=1.2, horiz=TRUE, bty="n", pch=15, inset=c(3.9,-0.32), xpd=TRUE) 


barplot(t(ppt.comb), beside=TRUE, ylab="Total seasonal precipitation (mm)", cex.names=0.8, col=c("black","grey50","grey80"), border=FALSE, las=1)
arrows(1,-80,40,-80, lwd=4, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
arrows(49,-80,52,-80, lwd=4, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
arrows(57,-80,60,-80, lwd=4, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
arrows(65,-80,68,-80, lwd=4, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
arrows(73,-80,76,-80, lwd=4, angle=90, code=3, length=0, col=colz[1],xpd=TRUE)
arrows(1,-90,40,-90, lwd=4, angle=90, code=3, length=0, col=colz[2],xpd=TRUE)
arrows(1,-100,20,-100, lwd=4, angle=90, code=3, length=0, col=colz[5],xpd=TRUE)
arrows(21,-110,40,-110, lwd=4, angle=90, code=3, length=0, col=colz[6],xpd=TRUE)

arrows(1,-120,4,-120, lwd=4, angle=90, code=3, length=0, col=colz[3],xpd=TRUE)
arrows(9,-120,12,-120, lwd=4, angle=90, code=3, length=0, col=colz[3],xpd=TRUE)
arrows(17,-120,20,-120, lwd=4, angle=90, code=3, length=0, col=colz[3],xpd=TRUE)
arrows(25,-120,28,-120, lwd=4, angle=90, code=3, length=0, col=colz[3],xpd=TRUE)
arrows(33,-120,36,-120, lwd=4, angle=90, code=3, length=0, col=colz[3],xpd=TRUE)

arrows(5,-130,8,-130, lwd=4, angle=90, code=3, length=0, col=colz[4],xpd=TRUE)
arrows(13,-130,16,-130, lwd=4, angle=90, code=3, length=0, col=colz[4],xpd=TRUE)
arrows(21,-130,24,-130, lwd=4, angle=90, code=3, length=0, col=colz[4],xpd=TRUE)
arrows(29,-130,32,-130, lwd=4, angle=90, code=3, length=0, col=colz[4],xpd=TRUE)
arrows(37,-130,40,-130, lwd=4, angle=90, code=3, length=0, col=colz[4],xpd=TRUE)

legend("topright", c("Full dataset","2004-2013","2004-2013 even yrs only","2004-2013 odd yrs only",
       "2004-2008","2009-2013"), col=colz[1:6], cex=0.83, horiz=FALSE, bty="y", lty="solid",lwd=4) 

```



## SET UP FOR IPM
```{r}

## SPECIFIY MIN AND MAX PLANT SIZE
minsize <- 1
maxsize <- (max(erbr$RosNew, na.rm=TRUE)) 


## FOR MEDIAN SIZE ESTIMATION
## From Dan's bistorts to guppies code 
##new size density estimation for median size estimation
pdfsz=density(erbr$RosNew, n=1024, cut=0, na.rm=TRUE) 
pdfsz2=cbind(pdfsz$x,pdfsz$y)
## This is a set of smoothed values that can then be used with weightedMedian in the matrixStats package to get a 'good' median for each class.

```




## LOAD MODEL OUTPUT FROM JAGS RUN
```{r}

## Load chains for all parameters
#jags.mod <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbr_JAGSmodBest_c3t10s30b10_noYRE_20230420.rds")
#chains <- jags.mod$mcmc
#chains <- bind_rows(lapply(chains, as.data.frame)) #Sometimes get error about coercing mcmc object to data.frame. Find alternate way of doing this.**


## Save 'chains' variable for easy re-loading
#saveRDS(chains, file="chains.c3t10s30b10_noYRE_20230420.rds")
#chainsOld <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/Archive_Files/chains.c3t10s30b10_noYRE_210613.rds")
chains <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/chains.c3t10s30b10_noYRE_20230420.rds")

```





## IPM - COMPARE OUTPUT BASED ON DIFFERENT NUMBERs OF SIZE BINS
```{r}

## DEFINE NUMBER OF SIZE BINS TO USE 
## For determining appropriate number of bins
bin.num <- c(5,10,20,30,40,45,50,55,60,65,70,75,80,90,100)  



## CALCULATE MEDIAN PARAMETER VALUES (exclude param uncertainty here)
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)



## CALCULATE MEAN CLIMATE CONDITIONS 
climStudyYrs <- clim32yr[clim32yr$Year>2003 & clim32yr$Year<2019,] #Subset to keep yrs of study period only
climMeans <- colMeans(climStudyYrs)



## CREATE VARIABLES TO STORE OUTPUT 
column.names <- c("BIN.NUM","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=length(bin.num), ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$BIN.NUM <- rep(bin.num)



## LOOP OVER DIFFERENT NUMBERS OF BINS
for (bb in 1:length(bin.num)) {
  
## Improved method of finding median size/ bin mids (code from Dan)
  vec.bin = c(minsize, minsize+1:bin.num[bb]*(maxsize-minsize)*(1/bin.num[bb])) 
  ## Do this block to make medians the focal estimated size for each cat
  binmids = rep(NA, length(vec.bin)-1)
      
  for(jj in 1:(length(vec.bin)-1)) {
      ## Set limits for subset according to bin breaks
      bounds <- c(vec.bin[jj], vec.bin[jj+1])
      ## Subset data according to bounds
      subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
      binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
      }
    
  n.bin = length(binmids)
  truebinsizes = n.bin  


  ## Initialize variable with input data for predictions
  in.data <- as.data.frame(binmids) 
  colnames(in.data) <- "RosNew"

        
        ## Plug in median param vals, mean climate and selected size predictor values for sz classes/ loop into model formulas
        ## Exclude random transect effects here (alternatively, could try mean values)
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) 
                          + medParams$grwth_TempFallCoef*climMeans["Mean_fall_temp"]
                          + medParams$grwth_TempSummerCoef*climMeans["Mean_summer_temp"]
                          + medParams$grwth_TempWinterCoef*climMeans["Mean_winter_temp"]
                          + medParams$grwth_PptFallCoef*climMeans["Tot_fall_ppt"]
                          + medParams$grwth_PptSummerCoef*climMeans["Tot_summer_ppt"]
                          + medParams$grwth_PptWinterCoef*climMeans["Tot_winter_ppt"])

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*in.data$RosNew + 
                                medParams$surv_PptWinterCoef*climMeans["Tot_winter_ppt"] + 
                                medParams$surv_TempWinterCoef*climMeans["Mean_winter_temp"] +
                                medParams$surv_TempSummerCoef*climMeans["Mean_summer_temp"] + 
                                medParams$surv_TempFallCoef*climMeans["Mean_fall_temp"])))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                                      medParams$reproyesno_PptFallCoef*climMeans["Tot_fall_ppt"] +
                                      medParams$reproyesno_PptSummerCoef*climMeans["Tot_summer_ppt"] +
                                      medParams$reproyesno_TempFallCoef*climMeans["Mean_fall_temp"] +
                                      medParams$reproyesno_TempSummerCoef*climMeans["Mean_summer_temp"] +
                                      medParams$reproyesno_TempWinterCoef*climMeans["Mean_winter_temp"]))) 

        ## Reproduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                          medParams$repro_PptFallCoef*climMeans["Tot_fall_ppt"] +
                          medParams$repro_PptSummerCoef*climMeans["Tot_summer_ppt"] +
                          medParams$repro_TempSummerCoef*climMeans["Mean_summer_temp"] +
                          medParams$repro_TempWinterCoef*climMeans["Mean_winter_temp"] +
                          medParams$repro_TempFallCoef*climMeans["Mean_fall_temp"])

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg <- 1            #Change ros size to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg) + 
                                medParams$surv_PptWinterCoef*climMeans["Tot_winter_ppt"] + 
                                medParams$surv_TempWinterCoef*climMeans["Mean_winter_temp"] +
                                medParams$surv_TempSummerCoef*climMeans["Mean_summer_temp"] + 
                                medParams$surv_TempFallCoef*climMeans["Mean_fall_temp"])))
    
        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))

        
        ## From Dan's code
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## Growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #Growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling surv in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.numSdlg                         #First row (new seedlings)
    
        lam.out.template[bb,2] <- Re(eigen(mx)$values[1])         #Calculate & store lambda
    
}  #End bb loop


## Look at results
lam.out.template

```




## IPM TO GET DETERMINISTIC LAMBDA, VRS, AND MATRICES FOR EACH TRANSECT & YEAR OF STUDY PERIOD
```{r}

## IPM ------------------------------
bin.num <- 50  #Define number of bins 

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
## Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  




## CREATE VARIABLES FOR OUTPUT
#climStudyYrs <- clim32yr[clim32yr$Year>2003 & clim32yr$Year<2023,]
clim32yr$Year <- as.factor(clim32yr$Year)
clim32yr <- clim32yr %>% rename(PptFall=Tot_fall_ppt, PptWinter=Tot_winter_ppt, PptSummer=Tot_summer_ppt,
                   TempFall=Mean_fall_temp, TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp)
clim32yr <- clim32yr %>% mutate(PptFall1=lead(PptFall), PptWinter1=lead(PptWinter), PptSummer1=lead(PptSummer),
                   TempFall1=lead(TempFall), TempWinter1=lead(TempWinter), TempSummer1=lead(TempSummer))
clim32yr <- clim32yr[14:32,]       #Subset to only include study-period years 


params <- 1000  #Number of iterations for param uncertainty eg. 1000
#num.year <- length(unique(erbr$Year))
num.year <- length(unique(clim32yr$Year))-1
num.transect <- length(unique(erbr$TransectNew))
#list.year <- sort(unique(erbr$Year))
list.year <- sort(unique(clim32yr$Year[1:(nrow(clim32yr)-1)]))
list.transect <- sort(unique(erbr$TransectNew))

## Make dataframes to hold output
## Want lambda estimate for each parameter set, year, and transect 
column.names <- c("PARAM","YEAR","TRANSECT","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*params, ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew))
#lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=num.transect)
lam.out.template$YEAR <- rep(sort(clim32yr$Year[1:(nrow(clim32yr)-1)]), each=num.transect)
lam.out.template$PARAM <- rep(1:params, each=(nrow(lam.out.template)/params))
lam.out.param <- NULL      #Variable to store final lambda outputs

column.names.vrs <- c("PARAM","YEAR","TRANSECT","SZ","GRWTH","SURV","REPRO_PROB","REPRO_AMT","NEW_PLTS")
vrs.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*params*bin.num, ncol=length(column.names.vrs)))
colnames(vrs.template) <- column.names.vrs
vrs.template$SZ <- rep(binmids)
vrs.template$TRANSECT <- rep(unique(erbr$TransectNew), each=length(binmids))
vrs.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect*length(binmids)))
vrs.template$YEAR <- rep(sort(clim32yr$Year[1:(nrow(clim32yr)-1)]), each=(num.transect*length(binmids)))
vrs.template$PARAM <- rep(1:params, each=(nrow(vrs.template)/params))
vrs.param <- NULL          #Variable to store final vital rate outputs

mx.out.list <- NULL        #List variable to store all matrices


## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"


## List of random numbers that corresponds to a set of parameter values to be used in each iteration of param loop
randVals.param <- sample(1:nrow(chains), size=params, prob=NULL, replace=FALSE)



## Loop for parameter uncertainty
for (pp in 1:params) {
  template.param <- subset(lam.out.template, PARAM==pp)  #Subset output template by param in parameter loop 
  lam.out.yr <- NULL                                     #Reset output variable each year loop
  temp.vrs.param <- subset(vrs.template, PARAM==pp)  
  vrs.yr <- NULL  
  
  ## Randomly select set of param values for all vital rates from chain list 
  selParams <- chains[randVals.param[pp],]
  
  ## Separate out transect & yr random intercepts 
  randTrans.grwth <- names(selParams)[grep("grwth_Transect_random",names(selParams))]
  randTrans.surv <- names(selParams)[grep("surv_Transect_random",names(selParams))]
  randTrans.reproYesNo <- names(selParams)[grep("reproyesno_Transect_random",names(selParams))]
  randTrans.repro <- names(selParams)[grep("repro_Transect_random",names(selParams))]
  


  ## Loop over years and transects
  for (yy in 1:num.year) {
    template.yr <- subset(template.param, YEAR==list.year[yy])  #Subset output template based on yr in yr loop
    temp.vrs.yr <- subset(temp.vrs.param, YEAR==list.year[yy])
    vrs.trans <- NULL
    
    for (tt in 1:num.transect) {
      temp.vrs.trans <- subset(temp.vrs.yr, TRANSECT==list.transect[tt])  #Subset vital rate output template based on transect

      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(clim32yr$PptSummer[clim32yr$Year==list.year[yy]]), 
                 PptWinter=unique(clim32yr$PptWinter[clim32yr$Year==list.year[yy]]), 
                 PptFall=unique(clim32yr$PptFall[clim32yr$Year==list.year[yy]]), 
                 TempSummer=unique(clim32yr$TempSummer[clim32yr$Year==list.year[yy]]), 
                 TempFall=unique(clim32yr$TempFall[clim32yr$Year==list.year[yy]]),
                 TempWinter=unique(clim32yr$TempWinter[clim32yr$Year==list.year[yy]]), 
                 PptSummer1=unique(clim32yr$PptSummer1[clim32yr$Year==list.year[yy]]), 
                 PptWinter1=unique(clim32yr$PptWinter1[clim32yr$Year==list.year[yy]]),
                 PptFall1=unique(clim32yr$PptFall1[clim32yr$Year==list.year[yy]]), 
                 TempFall1=unique(clim32yr$TempFall1[clim32yr$Year==list.year[yy]]),
                 TempSummer1=unique(clim32yr$TempSummer1[clim32yr$Year==list.year[yy]]), 
                 TempWinter1=unique(clim32yr$TempWinter1[clim32yr$Year==list.year[yy]]))
      
                 
        
        ## Plug selected param vals for given loop, predictor vals for given yr, transect, & sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(selParams$grwth_intercept + selParams$grwth_RosCoef*log(in.data$RosNew) 
                      + selParams$grwth_TempFallCoef*in.data$TempFall1 + selParams$grwth_TempSummerCoef*in.data$TempSummer1 
                      + selParams$grwth_TempWinterCoef*in.data$TempWinter1 + selParams$grwth_PptFallCoef*in.data$PptFall1
                      + selParams$grwth_PptSummerCoef*in.data$PptSummer1 + selParams$grwth_PptWinterCoef*in.data$PptWinter1
                      + as.numeric(selParams[randTrans.grwth[tt]])) 
        pred.grwth[pred.grwth > maxsize] <- maxsize  #If predictions exceed bounds, change to max value

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(selParams$grwthvar_intercept + selParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(selParams$surv_intercept + selParams$surv_RosCoef*log(in.data$RosNew) + 
                     selParams$surv_PptWinterCoef*in.data$PptWinter1 + selParams$surv_TempWinterCoef*in.data$TempWinter1 +
                     selParams$surv_TempSummerCoef*in.data$TempSummer1 + selParams$surv_TempFallCoef*in.data$TempFall1 +
                     as.numeric(selParams[randTrans.surv[tt]]))))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(selParams$reproyesno_intercept + selParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           selParams$reproyesno_PptFallCoef*in.data$PptFall + selParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           selParams$reproyesno_TempFallCoef*in.data$TempFall + selParams$reproyesno_TempSummerCoef*in.data$TempSummer
                           + selParams$reproyesno_TempWinterCoef*in.data$TempWinter 
                           + as.numeric(selParams[randTrans.reproYesNo[tt]])))) 

        ## Reproduction (neg binom)
        pred.repro <- exp(selParams$repro_intercept + selParams$repro_RosCoef*log(in.data$RosNew) + 
                      selParams$repro_PptSummerCoef*in.data$PptSummer + selParams$repro_PptFallCoef*in.data$PptFall
                      + selParams$repro_TempFallCoef*in.data$TempFall + selParams$repro_TempSummerCoef*in.data$TempSummer
                      + selParams$repro_TempWinterCoef*in.data$TempWinter + as.numeric(selParams[randTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates
        

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(selParams$surv_intercept + selParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                                selParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + 
                                selParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 +
                                selParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + 
                                selParams$surv_TempFallCoef*in.dataSdlg$TempFall1 +
                                as.numeric(selParams[randTrans.surv[tt]]))))

        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(selParams$newplt_intercept + log(pred.repro))

        ## Store vital rate predictions
        temp.vrs.trans$GRWTH <- pred.grwth
        temp.vrs.trans$GRWTH_VAR <- pred.grwthVar
        temp.vrs.trans$SURV <- pred.surv
        temp.vrs.trans$REPRO_PROB <- pred.reproYesNo
        temp.vrs.trans$REPRO_AMT <- pred.repro
        temp.vrs.trans$NEW_PLTS <- pred.numSdlg
        vrs.trans <- rbind(vrs.trans, temp.vrs.trans)         #Combine VRs for all transects

   
        ## From Dan's code
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
    
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.reproYesNo * pred.numSdlg       #First row (new seedlings)
    
        template.yr[tt,4] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        mx.out.list[[length(mx.out.list) + 1]] <- mx
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, template.yr)     #Combine lambda values for all years 
        vrs.yr <- rbind(vrs.yr, vrs.trans)               #Combine vital rate values for all years 
        
  }    #End yy loop

  lam.out.param <- rbind(lam.out.param, lam.out.yr)      #Combine lambda values for all parameter values
  vrs.param <- rbind(vrs.param, vrs.yr)                  #Combine vital rate values for all parameter values

}    #End pp loop

```



```{r}

## SAVE OUTPUT
## Save lambda & vital rate output 
date <- Sys.Date()        #Get date to be added to file name
date <- str_replace_all(date, "-", "")
#date <- as.character(20230503) 
name <- as.character("P1k")
saveRDS(lam.out.param, file=paste("erbrLams_noYRE", name, date, sep="_"))
saveRDS(vrs.param, file=paste("erbrVRs_noYRE", name, date, sep="_"))


## Save list of matrices as an R object for use in stochastic lambda script 
## Name each matrix by it's parameter, year, and transect
paramYrTrans.comb <- lam.out.template[,1:3]
names(mx.out.list) <- paste(as.character(paramYrTrans.comb$YEAR), as.character(paramYrTrans.comb$TRANSECT), sep='_')
names(mx.out.list) <- paste(as.character(paramYrTrans.comb$PARAM), names(mx.out.list), sep="-")
names(mx.out.list) <- paste("p", names(mx.out.list), sep="")

## ** ## Check if first sz class is seedlings in the next year or not. **
  ## Currently model assumes plt is always in the smallest subsequent sz class if you survive. ***
## *****

#date <- as.character(221129) 
name <- as.character("P1k")
saveRDS(mx.out.list, file=paste("erbrIPMmxList_noYRE", name, date, sep="_"))
#write.csv(mx.out.list[1], file=paste("erbrIPMmxList_noYRE", date, "p1.csv", sep="_"))
#saveRDS(mx.out.list[1:240], file=paste("erbrIPMmxList_noYRE", "P1only", date, sep="_"))


##READ IN SAVED FILE
lam.out.param <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrLams_noYRE_P1k_20230503")
#vrs.param <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/ErBr/erbrVRs_noYRE_P1k_20230503")


## LOOK AT RESULTS
cols <- viridis(12)
par(mfrow=c(5,4))                      #Plot in 20 panels
par(mar=c(2,3.9,2,2), mgp = c(2.3, 1, 0))  

for (pp in 1:length(list.year)) {
  lam.yr <- subset(lam.out.param, YEAR==list.year[pp])
  boxplot(LAMBDA ~ TRANSECT, data=lam.yr, main=paste(as.character(list.year[pp])),ylim=c(0.3,1.3),
  xaxt='n',xlab=NA, cex=0.5, ylab="Lambda", cex.lab=1.6, cex.axis=1.4, font.main=1, cex.main=1.7,
  medlwd=1,col=cols)
  abline(h=1,col="red", lwd=0.75)
  #text(6,0.01, "Transect", pos=1, xpd=TRUE, cex=1.5)
}

```





## LOOK AT RELATIONSHIP B/W LAMBDA PER TRANSECT & NUM PLTS PER TRANSECT
```{r}

## To address the question of if poorer performing transects just have very few plants 

## Calc mean lambda in each year-transect combo
lam.means.yrTrans <- lam.out.param %>% group_by(YEAR, TRANSECT) %>% summarise(MEAN=mean(LAMBDA))

## Calc num of indiv plants per year and transect 
num.indivs <- erbr %>% group_by(Year, TransectNew) %>% summarise(numIndivs=sum(surv, na.rm=TRUE)) 
num.indivs <- rename(num.indivs, TRANSECT=TransectNew, YEAR=Year)

## Combine data
lams.nums <- dplyr::left_join(num.indivs, lam.means.yrTrans, by=c("YEAR","TRANSECT"))

## Remove years with no data
lams.nums <- lams.nums[lams.nums$YEAR!="2014",]
lams.nums <- lams.nums[lams.nums$YEAR!="2015",]
lams.nums <- lams.nums[lams.nums$YEAR!="2017",]


mod <- lmer(MEAN ~ numIndivs + (1|YEAR) + (1|TRANSECT), data=lams.nums)
summary(mod)
car::Anova(mod)
par(mar=c(5,5,2,2))  
plot(lams.nums$numIndivs, lams.nums$MEAN, xlab="Number of individuals", ylab="Deterministic lambda",
     pch=16, cex.lab=1.6, cex.axis=1.3, cex=0.8)

```





## LOOK AT RELATIONSHIP B/W EACH VR AND PLT SIZE
```{r}

## Load vrs for different datasets
vrs.param <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_P1k_20230726")
#vrs.param4to8 <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_4to8_P1k_20231028")
vrs.param4to13 <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_4to13_P1k_20231026")
#vrs.param4to13evn <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_4to13even_P#1k_20231026")
#vrs.param4to13odd <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_4to13odd_P1#k_20231026")
#vrs.param9to13 <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrVRs_noYRE_9to13_P1k_20231028")



## In all years 
## ** Should this include NON-STUDY or just STUDY years? ***
vrs.mean <- vrs.param %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                           MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                           MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
vrs.mean4to13 <- vrs.param4to13 %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                           MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                           MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
#vrs.mean4to13odd <- vrs.param4to13odd %>% group_by(SZ) %>% #dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                           MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                           MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
#vrs.mean4to13evn <- vrs.param4to13evn %>% group_by(SZ) %>% #dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                           MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                           MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))


## In driest and wettest years 
#clim32yr$Year <- as.factor(clim32yr$Year)
clim32yr <- clim32yr %>% rename(PptFall=Tot_fall_ppt, PptWinter=Tot_winter_ppt, PptSummer=Tot_summer_ppt,
                   TempFall=Mean_fall_temp, TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp)
clim32yr <- clim32yr %>% mutate(PptFall1=lead(PptFall), PptWinter1=lead(PptWinter), PptSummer1=lead(PptSummer),
                   TempFall1=lead(TempFall), TempWinter1=lead(TempWinter), TempSummer1=lead(TempSummer))
#clim32yr <- clim32yr[14:32,]       #Subset to only include study-period years 
#dats.clim <- erbr %>% dplyr::select(c(Year, PptWinter, PptSummer, TempWinter, TempSummer,PptFall,TempFall, 
#                                      PptWinter1, PptSummer1, TempWinter1, TempSummer1)) 
dats.clim <- clim32yr %>% dplyr::select(c(Year, PptWinter, PptSummer, TempWinter, TempSummer,PptFall,TempFall, 
                                      PptWinter1, PptSummer1, TempWinter1, TempSummer1)) 

clim <- unique(dats.clim)
clim <- clim[order(clim$Year),]
climSums <-  clim %>% rowwise() %>% mutate(PPT_SUM=sum(PptWinter,PptSummer,PptFall))  #Add over 3 seasons for annual totals
min.ppt <- climSums$Year[which.min(climSums$PPT_SUM)] #2011
max.ppt <- climSums$Year[which.max(climSums$PPT_SUM)] #2015
## Note: 2007 is wettest year in 2004-2013 range 


## Subset lambdas by wettest and driest year 
vrs.minPpt <- subset(vrs.param, YEAR==min.ppt)
vrs.maxPpt <- subset(vrs.param, YEAR==max.ppt)
vrs.minPpt.mean <- vrs.minPpt %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
vrs.maxPpt.mean <- vrs.maxPpt %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))

vrs.minPpt4to13 <- subset(vrs.param4to13, YEAR==min.ppt)
vrs.maxPpt4to13 <- subset(vrs.param4to13, YEAR==max.ppt)
vrs.minPpt4to13.mean <- vrs.minPpt4to13 %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
vrs.maxPpt4to13.mean <- vrs.maxPpt4to13 %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))

#vrs.minPpt4to13odd <- subset(vrs.param4to13odd, YEAR==min.ppt)
#vrs.maxPpt4to13odd <- subset(vrs.param4to13odd, YEAR==max.ppt)
#vrs.minPpt4to13odd.mean <- vrs.minPpt4to13odd %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
#                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
#vrs.maxPpt4to13odd.mean <- vrs.maxPpt4to13odd %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
#                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))

#vrs.minPpt4to13evn <- subset(vrs.param4to13evn, YEAR==min.ppt)
#vrs.maxPpt4to13evn <- subset(vrs.param4to13evn, YEAR==max.ppt)
#vrs.minPpt4to13evn.mean <- vrs.minPpt4to13evn %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
#                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))
#vrs.maxPpt4to13evn.mean <- vrs.maxPpt4to13evn %>% group_by(SZ) %>% dplyr::summarize(MEAN_GRWTH=mean(GRWTH),
#                                                   MEAN_GRWTHVAR=mean(GRWTH_VAR),
#                                                   MEAN_SURV=mean(SURV),MEAN_REPROPROB=mean(REPRO_PROB),
#                                                   MEAN_REPROAMT=mean(REPRO_AMT),MEAN_NEWPLTS=mean(NEW_PLTS))


## ** ADD HOTTEST AND COOLEST YEARS TOO? **
## Year with warmest summer temp
#max.temp <- climSums$Year[which.max(climSums$TempSummer)] #2012
#min.temp <- climSums$Year[which.min(climSums$TempWinter)] #2008



##Plot results 
colz <- c("#d73027","#fc8d59")#,"#91bfdb","#4575b4")#,"grey60")
bin.num <- 50  #Define number of bins 

pdf('20240927_ErBr_fig3.pdf', width=6.5, height=7, pointsize=8)
par(mfrow=c(2,2))                               #Plot in 4 panels
par(mar=c(9.3,5.5,1.75,3), mgp = c(2.5, 1, 0))  #bottom, left, top, and right

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_GRWTH, xlab="Plant size in t (rosette number)",ylim=c(0,90), 
     ylab="Plant size in t+1\n(rosette number)", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25, col="#d73027",
     main="Growth")
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_GRWTH, col="#d73027",lwd=2,lty="dashed")
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_GRWTH, col="#d73027",lwd=2,lty="dotted")
lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_GRWTH, col="#fc8d59",lwd=2, lty="solid")
lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_GRWTH, col="#fc8d59",lwd=2, lty="dashed")
lines(vrs.param4to13$SZ[1:bin.num], vrs.maxPpt4to13.mean$MEAN_GRWTH, col="#fc8d59",lwd=2, lty="dotted")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.mean4to13evn$MEAN_GRWTH, col="#91bfdb",lwd=2, lty="solid")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.minPpt4to13evn.mean$MEAN_GRWTH, col="#91bfdb",lwd=2, lty="dashed")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.maxPpt4to13evn.mean$MEAN_GRWTH, col="#91bfdb",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_GRWTH, col="#4575b4",lwd=2, lty="solid")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_GRWTH, col="#4575b4",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.maxPpt4to13odd.mean$MEAN_GRWTH, col="#4575b4",lwd=2, lty="dotted")
#legend("bottomright","Growth", bty="n", cex=1.5)
#"2004-2013 even", "2004-2013 odd"

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_SURV, xlab="Plant size in t (rosette number)", 
     ylab="Survival probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25, col="#d73027",ylim=c(0.8,1),
     main="Survival")
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_SURV, col="#d73027",lwd=2,lty="dashed")
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_SURV, col="#d73027",lwd=2,lty="dotted")
lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_SURV, col="#fc8d59",lwd=2, lty="solid")
lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_SURV, col="#fc8d59",lwd=2, lty="dashed")
lines(vrs.param4to13$SZ[1:bin.num], vrs.maxPpt4to13.mean$MEAN_SURV, col="#fc8d59",lwd=2, lty="dotted")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.mean4to13evn$MEAN_SURV, col="#91bfdb",lwd=2, lty="solid")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.minPpt4to13evn.mean$MEAN_SURV, col="#91bfdb",lwd=2, lty="dashed")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.maxPpt4to13evn.mean$MEAN_SURV, col="#91bfdb",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_SURV, col="#4575b4",lwd=2, lty="solid")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_SURV, col="#4575b4",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.maxPpt4to13odd.mean$MEAN_SURV, col="#4575b4",lwd=2, lty="dotted")
#legend("bottomright","Survival", bty="n", cex=1.5)

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROPROB, xlab="Plant size in t (rosette number)", 
     ylab="Reproduction probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25, col="#d73027",ylim=c(0,1),
     main="Probability of reproducing")
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROPROB, col="#d73027",lwd=2,lty="dashed")
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROPROB, col="#d73027",lwd=2,lty="dotted")
lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_REPROPROB, col="#fc8d59",lwd=2, lty="solid")
lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_REPROPROB, col="#fc8d59",lwd=2, lty="dashed")
lines(vrs.param4to13$SZ[1:bin.num], vrs.maxPpt4to13.mean$MEAN_REPROPROB, col="#fc8d59",lwd=2, lty="dotted")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.mean4to13evn$MEAN_REPROPROB, col="#91bfdb",lwd=2, lty="solid")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.minPpt4to13evn.mean$MEAN_REPROPROB, col="#91bfdb",lwd=2, lty="dashed")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.maxPpt4to13evn.mean$MEAN_REPROPROB, col="#91bfdb",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_REPROPROB, col="#4575b4",lwd=2, lty="solid")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_REPROPROB, col="#4575b4",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.maxPpt4to13odd.mean$MEAN_REPROPROB, col="#4575b4",lwd=2, lty="dotted")
#legend("bottomright","p(Reproduction)", bty="n", cex=1.5)

plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROAMT, xlab="Plant size in t (rosette number)",ylim=c(0,155),
     ylab="Reproduction amount\n(inflorescence number)", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25, col="#d73027",
     main="Reproduction amount")
lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROAMT, col="#d73027",lwd=2,lty="dashed")
lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROAMT, col="#d73027",lwd=2,lty="dotted")
lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_REPROAMT, col="#fc8d59",lwd=2, lty="solid")
lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_REPROAMT, col="#fc8d59",lwd=2, lty="dashed")
lines(vrs.param4to13$SZ[1:bin.num], vrs.maxPpt4to13.mean$MEAN_REPROAMT, col="#fc8d59",lwd=2, lty="dotted")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.mean4to13evn$MEAN_REPROAMT, col="#91bfdb",lwd=2, lty="solid")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.minPpt4to13evn.mean$MEAN_REPROAMT, col="#91bfdb",lwd=2, lty="dashed")
#lines(vrs.param4to13evn$SZ[1:bin.num], vrs.maxPpt4to13evn.mean$MEAN_REPROAMT, col="#91bfdb",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_REPROAMT, col="#4575b4",lwd=2, lty="solid")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_REPROAMT, col="#4575b4",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.maxPpt4to13odd.mean$MEAN_REPROAMT, col="#4575b4",lwd=2, lty="dotted")
#legend("bottomright","Reproduction amount", bty="n", cex=1.5)
legend("bottomleft", c("Full dataset", "2004-2013"), col=colz,lwd=2,
       cex=1.1, inset=c(0,-0.4), xpd=TRUE, horiz=FALSE, bty="y",seg.len=1) #inset=c(-0.2,-0.4)
legend("bottomright", c("All years", "Wettest year", "Driest year"), col="black",lwd=1,cex=1.2,
       lty=c("solid","dotted","dashed"),
       inset=c(0,-0.44), xpd=TRUE, horiz=FALSE, bty="y",seg.len=1.5) #inset=c(-0.2,-0.44)

dev.off()
## --------------------------------------------------------------------------



#plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_SURV, xlab="Plant size in t (rosette number)", 
#     ylab="Survival probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25,ylim=c(0.85,1))
#lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_SURV, col="orange",lwd=2)
#lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_SURV, col="dodgerblue",lwd=2)
#lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_SURV, col="black",lwd=2, lty="dashed")
#lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_SURV, col="orange",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_SURV, col="black",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_SURV, col="orange",lwd=2, lty="dotted")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.mean9to13$MEAN_SURV, col="black",lwd=2, lty="dotdash")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.minPpt9to13.mean$MEAN_SURV, col="orange",lwd=2, lty="dotdash")

#plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROPROB, xlab="Plant size in t (rosette number)", 
#     ylab="Reproduction probability", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25,ylim=c(0,1.05))
#lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROPROB, col="orange",lwd=2)
#lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROPROB, col="dodgerblue",lwd=2)
#lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_REPROPROB, col="black",lwd=2, lty="dashed")
#lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_REPROPROB, col="orange",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_REPROPROB, col="black",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_REPROPROB, col="orange",lwd=2, lty="dotted")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.mean9to13$MEAN_REPROPROB, col="black",lwd=2, lty="dotdash")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.minPpt9to13.mean$MEAN_REPROPROB, col="orange",lwd=2, lty="dotdash")

#plot(vrs.param$SZ[1:bin.num], vrs.mean$MEAN_REPROAMT,xlab="Plant size in t (rosette number)",ylim=c(0,150), 
#     ylab="Reproduction amount\n(inflorescence number)", type='l',lwd=2,cex.lab=1.5, cex.axis=1.25)
#lines(vrs.param$SZ[1:bin.num], vrs.minPpt.mean$MEAN_REPROAMT, col="orange",lwd=2)
#lines(vrs.param$SZ[1:bin.num], vrs.maxPpt.mean$MEAN_REPROAMT, col="dodgerblue",lwd=2)
#lines(vrs.param4to13$SZ[1:bin.num], vrs.mean4to13$MEAN_REPROAMT, col="black",lwd=2, lty="dashed")
#lines(vrs.param4to13$SZ[1:bin.num], vrs.minPpt4to13.mean$MEAN_REPROAMT, col="orange",lwd=2, lty="dashed")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.mean4to13odd$MEAN_REPROAMT, col="black",lwd=2, lty="dotted")
#lines(vrs.param4to13odd$SZ[1:bin.num], vrs.minPpt4to13odd.mean$MEAN_REPROAMT, col="orange",lwd=2, lty="dotted")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.mean9to13$MEAN_REPROAMT, col="black",lwd=1.95, lty="dotdash")
#lines(vrs.param9to13$SZ[1:bin.num], vrs.minPpt9to13.mean$MEAN_REPROAMT, col="orange",lwd=2, lty="dotdash")

```





## IMPORTANCE OF EACH VR TO LAMBDA - VITAL RATE ELASTICITIES
```{r}

## IPM

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
##Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  



## CALCULATE MEDIAN PARAMETER VALUES 
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)

## Separate out transect & year random intercepts 
medTrans.grwth <- names(medParams)[grep("grwth_Transect_random",names(medParams))]
medTrans.surv <- names(medParams)[grep("surv_Transect_random",names(medParams))]
medTrans.reproYesNo <- names(medParams)[grep("reproyesno_Transect_random",names(medParams))]
medTrans.repro <- names(medParams)[grep("repro_Transect_random",names(medParams))]





## CREATE VARIABLES FOR OUTPUT 
num.year <- length(unique(erbr$Year))
num.transect <- length(unique(erbr$TransectNew))
list.year <- sort(unique(erbr$Year))
list.transect <- sort(unique(erbr$TransectNew))


## Perturbation amount
pert.amt <- 0.99 

## Make matrices to hold output
column.names <- c("YEAR","TRANSECT","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect, ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew))
lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect))

lam.out.yr <- NULL                                   
lam.out.yr.surv <- NULL
lam.out.yr.grwth <- NULL                                   
lam.out.yr.numSdlg <- NULL



## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"

 

## Loops for year and transect
for (yy in 1:num.year) {
    template.yr <- subset(lam.out.template, YEAR==list.year[yy])  
    template.yr.surv <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.grwth <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.reproYesNo <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.repro <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.numSdlg <- subset(lam.out.template, YEAR==list.year[yy])
    
    
    for (tt in 1:num.transect) {
      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(erbr$PptSummer[erbr$Year==list.year[yy]]), 
                 PptWinter=unique(erbr$PptWinter[erbr$Year==list.year[yy]]), 
                 PptFall=unique(erbr$PptFall[erbr$Year==list.year[yy]]), 
                 TempSummer=unique(erbr$TempSummer[erbr$Year==list.year[yy]]), 
                 TempFall=unique(erbr$TempFall[erbr$Year==list.year[yy]]),
                 TempWinter=unique(erbr$TempWinter[erbr$Year==list.year[yy]]), 
                 PptSummer1=unique(erbr$PptSummer1[erbr$Year==list.year[yy]]), 
                 PptWinter1=unique(erbr$PptWinter1[erbr$Year==list.year[yy]]),
                 PptFall1=unique(erbr$PptFall1[erbr$Year==list.year[yy]]), 
                 TempFall1=unique(erbr$TempFall1[erbr$Year==list.year[yy]]),
                 TempSummer1=unique(erbr$TempSummer1[erbr$Year==list.year[yy]]), 
                 TempWinter1=unique(erbr$TempWinter1[erbr$Year==list.year[yy]]))
        
        
        ## Plug selected param vals for given loop, and selected predictor values for given year, transect, and sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) + medParams$grwth_TempFallCoef*in.data$TempFall1
                      + medParams$grwth_TempSummerCoef*in.data$TempSummer1 + medParams$grwth_TempWinterCoef*in.data$TempWinter1
                      + medParams$grwth_PptFallCoef*in.data$PptFall1 + medParams$grwth_PptSummerCoef*in.data$PptSummer1
                      + medParams$grwth_PptWinterCoef*in.data$PptWinter1 + as.numeric(medParams[medTrans.grwth[tt]])) 

        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.data$RosNew) + 
                                medParams$surv_PptWinterCoef*in.data$PptWinter1 + 
                                medParams$surv_TempWinterCoef*in.data$TempWinter1 +
                                medParams$surv_TempSummerCoef*in.data$TempSummer1 + 
                                medParams$surv_TempFallCoef*in.data$TempFall1 +
                                as.numeric(medParams[medTrans.surv[tt]]))))

        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           medParams$reproyesno_PptFallCoef*in.data$PptFall + medParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           medParams$reproyesno_TempFallCoef*in.data$TempFall + medParams$reproyesno_TempSummerCoef*in.data$TempSummer +
                           medParams$reproyesno_TempWinterCoef*in.data$TempWinter + as.numeric(medParams[medTrans.reproYesNo[tt]])))) 

        ## Reroduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                      medParams$repro_PptFallCoef*in.data$PptFall + medParams$repro_PptSummerCoef*in.data$PptSummer +
                      medParams$repro_TempWinterCoef*in.data$TempWinter + medParams$repro_TempSummerCoef*in.data$TempSummer
                      + medParams$repro_TempFallCoef*in.data$TempFall + as.numeric(medParams[medTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                         medParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + 
                         medParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 +
                         medParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + 
                         medParams$surv_TempFallCoef*in.dataSdlg$TempFall1 +
                         as.numeric(medParams[medTrans.surv[tt]]))))
    
        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))
        pred.fec <- pred.reproYesNo * pred.numSdlg
        
        
    
        ## NON-PERTURBED ESTIMATES
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.yr[tt,3] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect

        
        
        ##SURVIVAL PERTURBATION
        pred.surv.pert <- pred.surv * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv.pert,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.yr.surv[tt,3] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        
        
        
        ##GROWTH PERTURBATION
        pred.grwth.pert <- pred.grwth * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth.pert[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                       #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                                  #First row (new seedlings)
    
        template.yr.grwth[tt,3] <- Re(eigen(mx)$values[1])             #Calculate lambda & store for each transect
        
      
        
        ##FECUNDITY PERTURBATION (PROB REPRO, REPRO AMT, AND NUM SEEDLING)
        pred.fec.pert <- pred.fec * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                                #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec.pert                                      #First row (new seedlings)
    
        template.yr.numSdlg[tt,3] <- Re(eigen(mx)$values[1])                    #Calculate lambda & store for each transect
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, template.yr)                                      #Combine lambda values for all years 
        lam.out.yr.surv <- rbind(lam.out.yr.surv, template.yr.surv)                       #Combine lambda values for all years 
        lam.out.yr.grwth <- rbind(lam.out.yr.grwth, template.yr.grwth)                    #Combine lambda values for all years 
        lam.out.yr.numSdlg <- rbind(lam.out.yr.numSdlg, template.yr.numSdlg)              #Combine lambda values for all years 
  }    #End yy loop

  



## CALCULATE AND PLOT ELASTICITIES
lam.out.yr.surv$FRAC.DIFF <- (lam.out.yr.surv$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.surv$ELAS <- lam.out.yr.surv$FRAC.DIFF / -0.01

lam.out.yr.grwth$FRAC.DIFF <- (lam.out.yr.grwth$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.grwth$ELAS <- lam.out.yr.grwth$FRAC.DIFF / -0.01

lam.out.yr.numSdlg$FRAC.DIFF <- (lam.out.yr.numSdlg$LAMBDA - lam.out.yr$LAMBDA)/lam.out.yr$LAMBDA
lam.out.yr.numSdlg$ELAS <- lam.out.yr.numSdlg$FRAC.DIFF / -0.01

mean(lam.out.yr.grwth$ELAS)
mean(lam.out.yr.surv$ELAS)
mean(lam.out.yr.numSdlg$ELAS)


## Plot results 
## Boxplots
par(mfrow=c(1,3))                            
par(mar=c(4,5,2,3), mgp = c(2.6, 1, 0))      #bottom, left, top, and right
boxplot(lam.out.yr.grwth$ELAS, xlab="Growth", ylab="Elasticity",
     cex.lab=1.7, cex.axis=1.4, cex=0.35, ylim=c(0,1))
boxplot(lam.out.yr.surv$ELAS, xlab="Survival", ylab="Elasticity",
     cex.lab=1.7, cex.axis=1.4, cex=0.35, ylim=c(0,1))
boxplot(lam.out.yr.numSdlg$ELAS, xlab="Fecundity", 
     ylab="Elasticity",cex.lab=1.7, cex.axis=1.4, cex=0.5, ylim=c(0,1))

```




## IMPORTANCE OF EACH VR TO LAMBDA - SIZE-CLASS SPECIFIC ELASTICITIES
```{r}

## IPM

## Improved method of finding median size/ bin mids (code from Dan)
vec.bin = c(minsize, minsize+1:bin.num*(maxsize-minsize)*(1/bin.num)) 
##Do this block to make medians the focal estimated size for each cat
binmids = rep(NA, length(vec.bin)-1)
    
for(jj in 1:(length(vec.bin)-1)) {
    # set limits for subset according to bin breaks
    bounds <- c(vec.bin[jj], vec.bin[jj+1])
    # subset data according to bounds
    subsetszs <- pdfsz2[which(pdfsz2[,1] >= bounds[1] & pdfsz2[,1] < bounds[2]),]
    binmids[jj] <- weightedMedian(subsetszs[,1],subsetszs[,2])
    }
  
n.bin = length(binmids)
truebinsizes = n.bin  




## CALCULATE MEDIAN PARAMETER VALUES 
medParams <- as.data.frame(colMedians(as.matrix(chains)))
medParams <-as.data.frame(t(as.data.frame(medParams)))
colnames(medParams) <- colnames(chains)

## Separate out transect random intercepts 
medTrans.grwth <- names(medParams)[grep("grwth_Transect_random",names(medParams))]
medTrans.surv <- names(medParams)[grep("surv_Transect_random",names(medParams))]
medTrans.reproYesNo <- names(medParams)[grep("reproyesno_Transect_random",names(medParams))]
medTrans.repro <- names(medParams)[grep("repro_Transect_random",names(medParams))]





## CREATE VARIABLES FOR OUTPUT 
num.year <- length(unique(erbr$Year))
num.transect <- length(unique(erbr$TransectNew))
list.year <- sort(unique(erbr$Year))
list.transect <- sort(unique(erbr$TransectNew))


## Perturbation amount
pert.amt <- 0.99 

## Make matrices to hold output
column.names <- c("YEAR","TRANSECT","SZ_CLASS","LAMBDA")
lam.out.template <- as.data.frame(matrix(NA, nrow=num.year*num.transect*(n.bin), ncol=length(column.names)))
colnames(lam.out.template) <- column.names
lam.out.template$SZ_CLASS <- rep(1:n.bin)
lam.out.template$TRANSECT <- rep(unique(erbr$TransectNew), each=n.bin)
lam.out.template$YEAR <- rep(sort(unique(erbr$Year)), each=(num.transect*n.bin))

lam.out.yr <- NULL                #Reset output variable for year loop if doing param loop
lam.out.yr.surv <- NULL
lam.out.yr.grwth <- NULL                                   
lam.out.yr.reproYesNo <- NULL
lam.out.yr.repro <- NULL                                   
lam.out.yr.numSdlg <- NULL


## Initialize variable with input data for predictions
in.data <- as.data.frame(binmids) 
colnames(in.data) <- "RosNew"


## Loops for year and transect
  for (yy in 1:num.year) {
    template.yr <- subset(lam.out.template, YEAR==list.year[yy])  
    template.yr.surv <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.grwth <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.reproYesNo <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.repro <- subset(lam.out.template, YEAR==list.year[yy])
    template.yr.numSdlg <- subset(lam.out.template, YEAR==list.year[yy])
    
    lam.out.trans <- NULL 
    lam.out.trans.surv <- NULL
    lam.out.trans.grwth <- NULL
    lam.out.trans.reproYesNo <- NULL
    lam.out.trans.numSdlg <- NULL

    
    for (tt in 1:num.transect) {
      template.trans <- subset(template.yr, TRANSECT==list.transect[tt])  
      template.trans.surv <- subset(template.yr, TRANSECT==list.transect[tt])
      template.trans.grwth <- subset(template.yr, TRANSECT==list.transect[tt])
      template.trans.reproYesNo <- subset(template.yr, TRANSECT==list.transect[yy])
      template.trans.repro <- subset(template.yr, TRANSECT==list.transect[yy])
      template.trans.numSdlg <- subset(template.yr, TRANSECT==list.transect[tt])

      ## Define different variable combinations for which to estimate lambda
      in.data$Year <- list.year[yy]
      in.data$TransectNew <- list.transect[tt]
      in.data <- in.data %>% mutate(PptSummer=unique(erbr$PptSummer[erbr$Year==list.year[yy]]), 
                 PptWinter=unique(erbr$PptWinter[erbr$Year==list.year[yy]]), 
                 PptFall=unique(erbr$PptFall[erbr$Year==list.year[yy]]), 
                 TempSummer=unique(erbr$TempSummer[erbr$Year==list.year[yy]]), 
                 TempFall=unique(erbr$TempFall[erbr$Year==list.year[yy]]),
                 TempWinter=unique(erbr$TempWinter[erbr$Year==list.year[yy]]), 
                 PptSummer1=unique(erbr$PptSummer1[erbr$Year==list.year[yy]]), 
                 PptWinter1=unique(erbr$PptWinter1[erbr$Year==list.year[yy]]),
                 PptFall1=unique(erbr$PptFall1[erbr$Year==list.year[yy]]), 
                 TempFall1=unique(erbr$TempFall1[erbr$Year==list.year[yy]]),
                 TempSummer1=unique(erbr$TempSummer1[erbr$Year==list.year[yy]]), 
                 TempWinter1=unique(erbr$TempWinter1[erbr$Year==list.year[yy]]))
        
        
        ## Plug selected param vals for given loop, and selected predictor values for given year, transect, and sz class into model formulas
        ## Growth (neg binom)
        pred.grwth <- exp(medParams$grwth_intercept + medParams$grwth_RosCoef*log(in.data$RosNew) 
                      + medParams$grwth_TempFallCoef*in.data$TempFall1 + medParams$grwth_TempSummerCoef*in.data$TempSummer1
                      + medParams$grwth_TempWinterCoef*in.data$TempWinter1 + medParams$grwth_PptFallCoef*in.data$PptFall1
                      + medParams$grwth_PptSummerCoef*in.data$PptSummer1 + medParams$grwth_PptWinterCoef*in.data$PptWinter1
                      + as.numeric(medParams[medTrans.grwth[tt]])) 
        
        ## Variance in growth (neg binom)
        pred.grwthVar <- exp(medParams$grwthvar_intercept + medParams$grwthvar_RosCoef*log(in.data$RosNew)) 

        ## Survival (binom)  
        pred.surv <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.data$RosNew) + 
                     medParams$surv_PptWinterCoef*in.data$PptWinter1 + medParams$surv_TempWinterCoef*in.data$TempWinter1 
                     + medParams$surv_TempSummerCoef*in.data$TempSummer1 + medParams$surv_TempFallCoef*in.data$TempFall1 
                     + as.numeric(medParams[medTrans.surv[tt]]))))
        
        ## Probability of reproducing (binom)  
        pred.reproYesNo <- 1/(1+exp(-(medParams$reproyesno_intercept + medParams$reproyesno_RosCoef*log(in.data$RosNew) +
                           medParams$reproyesno_PptFallCoef*in.data$PptFall + medParams$reproyesno_PptSummerCoef*in.data$PptSummer +
                           medParams$reproyesno_TempFallCoef*in.data$TempFall + medParams$reproyesno_TempSummerCoef*in.data$TempSummer +
                           medParams$reproyesno_TempWinterCoef*in.data$TempWinter + as.numeric(medParams[medTrans.reproYesNo[tt]])))) 
                                      
        
        ## Reproduction (neg binom)
        pred.repro <- exp(medParams$repro_intercept + medParams$repro_RosCoef*log(in.data$RosNew) + 
                      medParams$repro_PptFallCoef*in.data$PptFall + medParams$repro_PptSummerCoef*in.data$PptSummer +
                      medParams$repro_TempWinterCoef*in.data$TempWinter + medParams$repro_TempSummerCoef*in.data$TempSummer
                      + medParams$repro_TempFallCoef*in.data$TempFall + as.numeric(medParams[medTrans.repro[tt]]))
        pred.repro[pred.repro < 0] <- 0    #Correct for negative repro estimates

        ## Seedling survival (binom)  
        in.dataSdlg <- in.data[1,]  #Subset to keep only 1 row of in.data 
        in.dataSdlg$RosNew <- 1     #Change ros size in in.data to be 1 (sz of sdlg)
        pred.survSdlg <- 1/(1+exp(-(medParams$surv_intercept + medParams$surv_RosCoef*log(in.dataSdlg$RosNew) + 
                         medParams$surv_PptWinterCoef*in.dataSdlg$PptWinter1 + medParams$surv_TempWinterCoef*in.dataSdlg$TempWinter1 
                         + medParams$surv_TempSummerCoef*in.dataSdlg$TempSummer1 + medParams$surv_TempFallCoef*in.dataSdlg$TempFall1 
                         + as.numeric(medParams[medTrans.surv[tt]]))))

        ## Seedlings per inflor (neg binom)
        pred.numSdlg <- exp(medParams$newplt_intercept + log(pred.repro))
        pred.fec <- pred.reproYesNo * pred.numSdlg
        
   
        ## Loop over size classes 
        for (cc in 1:n.bin) {
        
          
        ## NON-PERTURBED ESTIMATES
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #If statement breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.trans[cc,4] <- Re(eigen(mx)$values[1])           #Calculate lambda & store for each transect

        
        
        ##SURVIVAL PERTURBATION
        pred.surv.pert <- pred.surv 
        pred.surv.pert[cc] <- pred.surv[cc] * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv.pert,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                  #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                             #First row (new seedlings)
    
        template.trans.surv[cc,4] <- Re(eigen(mx)$values[1])              #Calculate lambda & store for each transect
        
        
        
        ##GROWTH PERTURBATION
        pred.grwth.pert <- pred.grwth 
        pred.grwth.pert[cc] <- pred.grwth[cc] * pert.amt 
        pred.grwth.pert[pred.grwth.pert > maxsize] <- maxsize 
        
        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth.pert[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                       #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec                                  #First row (new seedlings)
    
        template.trans.grwth[cc,4] <- Re(eigen(mx)$values[1])          #Calculate lambda & store for each transect
        
        
        
        ##FECUNDITY PERTURBATION (PROB REPRO, REPRO AMT, AND NUM SEEDLING)
        pred.fec.pert <- pred.fec 
        pred.fec.pert[cc] <- pred.fec[cc] * pert.amt 

        ## Constructing matrix models
        grwth.mx <- matrix(data=NA, nrow=n.bin, ncol=n.bin)
        ## growth probs using cdf fn
        for (ss in 1:(n.bin)) {
          grwth.cdf <- pnorm(vec.bin, pred.grwth[ss], sqrt(pred.grwthVar[ss]))
          grwth <- grwth.cdf[2:length(vec.bin)] - grwth.cdf[1:(length(vec.bin)-1)]
          if (sum(grwth)>0) {   #'If' breaks code (puts NA's into mx) if sum of PDF is 0 (which happens if all prob is outside of sz bounds)
            grwth <- grwth/sum(grwth)
            grwth.mx[,ss] <- grwth
            } else {
              grwth.mx[,ss] <- NA
              } 
          } #End ss loop
        
        ## Make survival * growth matrix
        surv.grwth.mx <- grwth.mx * t(matrix(rep(pred.surv,(n.bin)),(n.bin)))
        mx1 <- surv.grwth.mx #growth and survival, without repro
        ## Add reproduction and recruitment
        mx <- matrix(0, (n.bin+1), (n.bin+1))
        mx[2:(n.bin+1), 2:(n.bin+1)] <- mx1
        mx[2,1] <- pred.survSdlg                                                 #First column (seedling survival in element 2,1)
        mx[1,2:(n.bin+1)] <- pred.fec.pert                                       #First row (new seedlings)
    
        template.trans.numSdlg[cc,4] <- Re(eigen(mx)$values[1])                  #Calculate lambda & store for each transect
        } # End cc (size class) loop
        
        lam.out.trans <- rbind(lam.out.trans, template.trans)  
        lam.out.trans.surv <- rbind(lam.out.trans.surv, template.trans.surv)                                      
        lam.out.trans.grwth <- rbind(lam.out.trans.numSdlg, template.trans.grwth) 
        lam.out.trans.numSdlg <- rbind(lam.out.trans.numSdlg, template.trans.numSdlg)                                      
        } # End tt loop
    
        lam.out.yr <- rbind(lam.out.yr, lam.out.trans)                                      #Combine lambda vals for all yrs 
        lam.out.yr.surv <- rbind(lam.out.yr.surv, lam.out.trans.surv)                       #Combine lambda vals for all yrs 
        lam.out.yr.grwth <- rbind(lam.out.yr.grwth, lam.out.trans.grwth)                    #Combine lambda vals for all yrs 
        lam.out.yr.numSdlg <- rbind(lam.out.yr.numSdlg, lam.out.trans.numSdlg)              #Combine lambda vals for all yrs 
  }    #End yy loop

  


## ESTIMATE AND PLOT ELASTICITIES
## Calculate mean elasticities across years and transects
lam.mn <- lam.out.yr %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.grwth <- lam.out.yr.grwth %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.surv <- lam.out.yr.surv %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))
lam.mn.numSdlg <- lam.out.yr.numSdlg %>% group_by(SZ_CLASS) %>% summarise(MEAN_LAM=mean(LAMBDA))

lam.mn.grwth$FRAC.DIFF <- (lam.mn.grwth$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.grwth$ELAS <- lam.mn.grwth$FRAC.DIFF / -0.01
lam.mn.surv$FRAC.DIFF <- (lam.mn.surv$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.surv$ELAS <- lam.mn.surv$FRAC.DIFF / -0.01
lam.mn.numSdlg$FRAC.DIFF <- (lam.mn.numSdlg$MEAN_LAM - lam.mn$MEAN_LAM)/lam.mn$MEAN_LAM
lam.mn.numSdlg$ELAS <- lam.mn.numSdlg$FRAC.DIFF / -0.01


## Plot results 
par(mfrow=c(3,1))                            
par(mar=c(4,5,2,3))
barplot(lam.mn.grwth$ELAS ~ lam.mn.grwth$SZ_CLASS, xlab="Size class", ylab="Growth elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)
barplot(lam.mn.surv$ELAS ~ lam.mn.surv$SZ_CLASS, xlab="Size class", ylab="Survival elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)
barplot(lam.mn.numSdlg$ELAS ~ lam.mn.numSdlg$SZ_CLASS, xlab="Size class", ylab="Fecundity elasticities",
     cex.lab=1.7, cex.axis=1.3, cex.names=1.3)

```





## HOW DOES LAMBDA VARY WITH CLIMATE?
```{r}

## LOOK AT RELATIONSHIP B/W LAMBDA & CLIMATE (USING STUDY YEARS OR 30+ YRS OF DATA)
lam.out.param <- readRDS("C:/Users/april/Dropbox/CU_Boulder_PhD/DBG_Internship/erbrLams_noYRE_P1k_20230503")

clim32yr <- clim32yr %>% rename(YEAR=Year, PptSummer=Tot_summer_ppt, PptWinter=Tot_winter_ppt, PptFall=Tot_fall_ppt,
                                TempWinter=Mean_winter_temp, TempSummer=Mean_summer_temp, TempFall=Mean_fall_temp) 
climStudyYrs <- clim32yr[clim32yr$YEAR>2003 & clim32yr$YEAR<2022,]  ##Only look at study years
climStudyYrs$YEAR <- as.factor(climStudyYrs$YEAR)

#lam.out.param <- lam.out.param[is.numeric(lam.out.param$YEAR)>2003,]
#lam.out.param.comb <- rbind(lam.out.param)#, lam.out.param.nsy)
lam.out.param.clim <- dplyr::right_join(lam.out.param, climStudyYrs, by="YEAR")




## Average across parameter uncertainty
lam.mean.yr <- lam.out.param.clim %>% group_by(YEAR) %>% dplyr::summarize(MEAN_LAM=mean(LAMBDA), PptSummer=mean(PptSummer),
                                                         TempWinter=mean(TempWinter), PptWinter=mean(PptWinter),
                                                         TempFall=mean(TempFall), PptFall=mean(PptFall), TempSummer=mean(TempSummer))

## ARE THESE STILL THE BEST CLIM VARS TO BE CONSIDERING? VR MODELS NOW CONTAIN ALL CLIM VARS 
## 3-way interaction model with relevant clim variables (e.g. summer and winter precip, and winter temp)
#lamVclim <- lm(MEAN_LAM ~ PptSummer * TempWinter * PptWinter, data=lam.mean.yr)
#summary(lamVclim)
#Anova(lamVclim)

summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$PptSummer))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$PptWinter))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$PptFall))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$TempSummer))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$TempWinter))
summary(lm(lam.mean.yr$MEAN_LAM ~ lam.mean.yr$TempFall))

par(mfrow=c(3,2))
par(pty="s")
par(mar=c(4.3,4.5,2,2))
plot(lam.mean.yr$PptSummer, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Total summer precipitation (mm)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$TempSummer, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Mean summer temperature (°C)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$PptFall, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Total fall precipitation (mm)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$TempFall, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Mean fall temperature (°C)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$PptWinter, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Total winter precipitation (mm)",
     cex.lab=1.5, cex.axis=1.25)
plot(lam.mean.yr$TempWinter, lam.mean.yr$MEAN_LAM, pch=16, ylab="Deterministic\nlambda", xlab="Mean winter temperature (°C)",
     cex.lab=1.5, cex.axis=1.25)

```